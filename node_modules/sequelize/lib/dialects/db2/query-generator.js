"REG_BINARY" value="0203004B000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 19200/ARQ/MNP&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0202004B000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 19200/ARQ/V32/LAPM/V42BIS&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0203004B000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 19200/ARQ/V32/LAPM&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0202004B000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 19200/ARQ/V32/MNP/MNP5&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0203004B000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 19200/ARQ/V32/MNP&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0202004B000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 19200/ARQ/V34/LAPM/V42BIS&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0203004B000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 19200/ARQ/V34/LAPM&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0202004B000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 19200/ARQ/V34/MNP/MNP5&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0203004B000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 19200/ARQ/V34/MNP&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0202004B000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 19200/ARQ&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0202004B000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 19200/NONE&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0200004B000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 19200/V32/NONE&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0200004B000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 19200/V34/NONE&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0200004B000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 21600/ARQ/LAPM/V42BIS&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02036054000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 21600/ARQ/LAPM&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02026054000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 21600/ARQ/MNP/MNP5&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02036054000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 21600/ARQ/MNP&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02026054000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 21600/ARQ/V32/LAPM/V42BIS&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02036054000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 21600/ARQ/V32/LAPM&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02026054000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 21600/ARQ/V32/MNP/MNP5&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02036054000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 21600/ARQ/V32/MNP&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02026054000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 21600/ARQ/V34/LAPM/V42BIS&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02036054000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 21600/ARQ/V34/LAPM&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02026054000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 21600/ARQ/V34/MNP/MNP5&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02036054000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 21600/ARQ/V34/MNP&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02026054000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 21600/ARQ&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02026054000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 21600/NONE&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02006054000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 21600/V32/NONE&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02006054000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 21600/V34/NONE&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02006054000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 2400/ARQ/LAPM/V42BIS&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02036009000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 2400/ARQ/LAPM&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02026009000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 2400/ARQ/MNP/MNP5&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02036009000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 2400/ARQ/MNP&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02026009000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 2400/ARQ&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02026009000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 2400/NONE&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02006009000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 24000/ARQ/LAPM/V42BIS&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0203C05D000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 24000/ARQ/LAPM&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0202C05D000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 24000/ARQ/MNP/MNP5&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0203C05D000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 24000/ARQ/MNP&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0202C05D000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 24000/ARQ/V32/LAPM/V42BIS&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0203C05D000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 24000/ARQ/V32/LAPM&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0202C05D000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 24000/ARQ/V32/MNP/MNP5&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0203C05D000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 24000/ARQ/V32/MNP&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0202C05D000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 24000/ARQ/V34/LAPM/V42BIS&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0203C05D000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 24000/ARQ/V34/LAPM&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0202C05D000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 24000/ARQ/V34/MNP/MNP5&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0203C05D000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 24000/ARQ/V34/MNP&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0202C05D000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 24000/ARQ&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0202C05D000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 24000/NONE&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0200C05D000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 24000/V32/NONE&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0200C05D000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 24000/V34/NONE&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0200C05D000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 26400/ARQ/LAPM/V42BIS&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02032067000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 26400/ARQ/LAPM&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02022067000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 26400/ARQ/MNP/MNP5&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02032067000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECTValue;
      }
      for (let i = 0; i < defs.length; i++) {
        const definition = defs[i];
        if (definition.match(/REFERENCES/)) {
          constraintString.push(_.template("<%= fkName %> FOREIGN KEY (<%= attrName %>) <%= definition %>", this._templateSettings)({
            fkName: this.quoteIdentifier(`${attributeName}_foreign_idx`),
            attrName: this.quoteIdentifier(attributeName),
            definition: definition.replace(/.+?(?=REFERENCES)/, "")
          }));
        } else if (_.startsWith(definition, "DROP ")) {
          attrString.push(_.template("<%= attrName %> <%= definition %>", this._templateSettings)({
            attrName: this.quoteIdentifier(attributeName),
            definition
          }));
        } else {
          attrString.push(_.template("<%= attrName %> SET <%= definition %>", this._templateSettings)({
            attrName: this.quoteIdentifier(attributeName),
            definition
          }));
        }
      }
    }
    let finalQuery = "";
    if (attrString.length) {
      finalQuery += `ALTER COLUMN ${attrString.join(" ALTER COLUMN ")}`;
      finalQuery += constraintString.length ? " " : "";
    }
    if (constraintString.length) {
      finalQuery += `ADD CONSTRAINT ${constraintString.join(" ADD CONSTRAINT ")}`;
    }
    return _.template(query, this._templateSettings)({
      tableName: this.quoteTable(tableName),
      query: finalQuery
    });
  }
  renameColumnQuery(tableName, attrBefore, attributes) {
    const query = "ALTER TABLE <%= tableName %> RENAME COLUMN <%= before %> TO <%= after %>;", newName = Object.keys(attributes)[0];
    return _.template(query, this._templateSettings)({
      tableName: this.quoteTable(tableName),
      before: this.quoteIdentifier(attrBefore),
      after: this.quoteIdentifier(newName)
    });
  }
  addConstraintQuery(tableName, options) {
    options = options || {};
    if (options.onUpdate && options.onUpdate.toUpperCase() === "CASCADE") {
      delete options.onUpdate;
    }
    const constraintSnippet = this.getConstraintSnippet(tableName, options);
    if (typeof tableName === "string") {
      tableName = this.quoteIdentifiers(tableName);
    } else {
      tableName = this.quoteTable(tableName);
    }
    return `ALTER TABLE ${tableName} ADD ${constraintSnippet};`;
  }
  bulkInsertQuery(tableName, attrValueHashes, options, attributes) {
    options = options || {};
    attributes = attributes || {};
    let query = "INSERT INTO <%= table %> (<%= attributes %>)<%= output %> VALUES <%= tuples %>;";
    if (options.returning) {
      query = "SELECT * FROM FINAL TABLE( INSERT INTO <%= table %> (<%= attributes %>)<%= output %> VALUES <%= tuples %>);";
    }
    const emptyQuery = "INSERT INTO <%= table %>", tuples = [], allAttributes = [], allQueries = [];
    let outputFragment;
    const valuesForEmptyQuery = [];
    if (options.returning) {
      outputFragment = "";
    }
    _.forEach(attrValueHashes, (attrValueHash) => {
      const fields = Object.keys(attrValueHash);
      const firstAttr = attributes[fields[0]];
      if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {
        valuesForEmptyQuery.push(`(${this.autoGenValue++})`);
        return;
      }
      _.forOwn(attrValueHash, (value, key) => {
        if (allAttributes.indexOf(key) === -1) {
          if (value === null && attributes[key] && attributes[key].autoIncrement)
            return;
          allAttributes.push(key);
        }
      });
    });
    if (valuesForEmptyQuery.length > 0) {
      allQueries.push(`${emptyQuery} VALUES ${valuesForEmptyQuery.join(",")}`);
    }
    if (allAttributes.length > 0) {
      _.forEach(attrValueHashes, (attrValueHash) => {
        tuples.push(`(${allAttributes.map((key) => this.escape(attrValueHash[key]), void 0, { context: "INSERT" }).join(",")})`);
      });
      allQueries.push(query);
    }
    const replacements = {
      table: this.quoteTable(tableName),
      attributes: allAttributes.map((attr) => this.quoteIdentifier(attr)).join(","),
      tuples,
      output: outputFragment
    };
    const generatedQuery = _.template(allQueries.join(";"), this._templateSettings)(replacements);
    return generatedQuery;
  }
  updateQuery(tableName, attrValueHash, where, options, attributes) {
    const sql = super.updateQuery(tableName, attrValueHash, where, options, attributes);
    options = options || {};
    _.defaults(options, this.options);
    if (!options.limit) {
      sql.query = `SELECT * FROM FINAL TABLE (${sql.query});`;
      return sql;
    }
    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);
    const modelAttributeMap = {};
    const values = [];
    const bind = [];
    const bindParam = options.bindParam || this.bindParam(bind);
    if (attributes) {
      _.each(attributes, (attribute, key) => {
        modelAttributeMap[key] = attribute;
        if (attribute.field) {
          modelAttributeMap[attribute.field] = attribute;
        }
      });
    }
    for (const key in attrValueHash) {
      const value = attrValueHash[key];
      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {
        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || void 0, { context: "UPDATE" })}`);
      } else {
        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || void 0, { context: "UPDATE" }, bindParam)}`);
      }
    }
    let query;
    const whereOptions = _.defaults({ bindParam }, options);
    query = `UPDATE (SELECT * FROM ${this.quoteTable(tableName)} ${this.whereQuery(where, whereOptions)} FETCH NEXT ${this.escape(options.limit)} ROWS ONLY) SET ${values.join(",")}`;
    query = `SELECT * FROM FINAL TABLE (${query});`;
    return { query, bind };
  }
  upsertQuery(tableName, insertValues, updateValues, where, model) {
    const targetTableAlias = this.quoteTable(`${tableName}_target`);
    const sourceTableAlias = this.quoteTable(`${tableName}_source`);
    const primaryKeysAttrs = [];
    const identityAttrs = [];
    const uniqueAttrs = [];
    const tableNameQuoted = this.quoteTable(tableName);
    for (const key in model.rawAttributes) {
      if (model.rawAttributes[key].primaryKey) {
        primaryKeysAttrs.push(model.rawAttributes[key].field || key);
      }
      if (model.rawAttributes[key].unique) {
        uniqueAttrs.push(model.rawAttributes[key].field || key);
      }
      if (model.rawAttributes[key].autoIncrement) {
        identityAttrs.push(model.rawAttributes[key].field || key);
      }
    }
    for (const index of model._indexes) {
      if (index.unique && index.fields) {
        for (const field of index.fields) {
          const fieldName = typeof field === "string" ? field : field.name || field.attribute;
          if (uniqueAttrs.indexOf(fieldName) === -1 && model.rawAttributes[fieldName]) {
            uniqueAttrs.push(fieldName);
          }
        }
      }
    }
    const updateKeys = Object.keys(updateValues);
    const insertKeys = Object.keys(insertValues);
    const insertKeysQuoted = insertKeys.map((key) => this.quoteIdentifier(key)).join(", ");
    const insertValuesEscaped = insertKeys.map((key) => this.escape(insertValues[key])).join(", ");
    const sourceTableQuery = `VALUES(${insertValuesEscaped})`;
    let joinCondition;
    const clauses = where[Op.or].filter((clause) => {
      let valid = true;
      for (const key in clause) {
        if (!clause[key]) {
          valid = false;
          break;
        }
      }
      return valid;
    });
    const getJoinSnippet = (array) => {
      return array.map((key) => {
        key = this.quoteIdentifier(key);
        return `${targetTableAlias}.${key} = ${sourceTableAlias}.${key}`;
      });
    };
    if (clauses.length === 0) {
      throw new Error("Primary Key or Unique key should be passed to upsert query");
    } else {
      for (const key in clauses) {
        const keys = Object.keys(clauses[key]);
        if (primaryKeysAttrs.indexOf(keys[0]) !== -1) {
          joinCondition = getJoinSnippet(primaryKeysAttrs).join(" AND ");
          break;
        }
      }
      if (!joinCondition) {
        joinCondition = getJoinSnippet(uniqueAttrs).join(" AND ");
      }
    }
    const filteredUpdateClauses = updateKeys.filter((key) => {
      if (identityAttrs.indexOf(key) === -1) {
        return true;
      }
      return false;
    }).map((key) => {
      const value = this.escape(updateValues[key]);
      key = this.quoteIdentifier(key);
      return `${targetTableAlias}.${key} = ${value}`;
    }).join(", ");
    const updateSnippet = filteredUpdateClauses.length > 0 ? `WHEN MATCHED THEN UPDATE SET ${filteredUpdateClauses}` : "";
    const insertSnippet = `(${insertKeysQuoted}) VALUES(${insertValuesEscaped})`;
    let query = `MERGE INTO ${tableNameQuoted} AS ${targetTableAlias} USING (${sourceTableQuery}) AS ${sourceTableAlias}(${insertKeysQuoted}) ON ${joinCondition}`;
    query += ` ${updateSnippet} WHEN NOT MATCHED THEN INSERT ${insertSnippet};`;
    return query;
  }
  truncateTableQuery(tableName) {
    return `TRUNCATE TABLE ${this.quoteTable(tableName)} IMMEDIATE`;
  }
  deleteQuery(tableName, where, options = {}, model) {
    const table = this.quoteTable(tableName);
    const query = "DELETE FROM <%= table %><%= where %><%= limit %>";
    where = this.getWhereConditions(where, null, model, options);
    let limit = "";
    if (options.offset > 0) {
      limit = ` OFFSET ${this.escape(options.offset)} ROWS`;
    }
    if (options.limit) {
      limit += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;
    }
    const replacements = {
      limit,
      table,
      where
    };
    if (replacements.where) {
      replacements.where = ` WHERE ${replacements.where}`;
    }
    return _.template(query, this._templateSettings)(replacements);
  }
  showIndexesQuery(tableName) {
    let sql = 'SELECT NAME AS "name", TBNAME AS "tableName", UNIQUERULE AS "keyType", COLNAMES, INDEXTYPE AS "type" FROM SYSIBM.SYSINDEXES WHERE TBNAME = <%= tableName %>';
    let schema = void 0;
    if (_.isObject(tableName)) {
      schema = tableName.schema;
      tableName = tableName.tableName;
    }
    if (schema) {
      sql = `${sql} AND TBCREATOR = <%= schemaName %>`;
    }
    sql = `${sql} ORDER BY NAME;`;
    return _.template(sql, this._templateSettings)({
      tableName: wrapSingleQuote(tableName),
      schemaName: wrapSingleQuote(schema)
    });
  }
  showConstraintsQuery(tableName, constraintName) {
    let sql = `SELECT CONSTNAME AS "constraintName", TRIM(TABSCHEMA) AS "schemaName", TABNAME AS "tableName" FROM SYSCAT.TABCONST WHERE TABNAME = '${tableName}'`;
    if (constraintName) {
      sql += ` AND CONSTNAME LIKE '%${constraintName}%'`;
    }
    return `${sql} ORDER BY CONSTNAME;`;
  }
  removeIndexQuery(tableName, indexNameOrAttributes) {
    const sql = "DROP INDEX <%= indexName %>";
    let indexName = indexNameOrAttributes;
    if (typeof indexName !== "string") {
      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join("_")}`);
    }
    const values = {
      tableName: this.quoteIdentifiers(tableName),
      indexName: this.quoteIdentifiers(indexName)
    };
    return _.template(sql, this._templateSettings)(values);
  }
  attributeToSQL(attribute, options) {
    if (!_.isPlainObject(attribute)) {
      attribute = {
        type: attribute
      };
    }
    let template;
    let changeNull = 1;
    if (attribute.type instanceof DataTypes.ENUM) {
      if (attribute.type.values && !attribute.values)
        attribute.values = attribute.type.values;
      template = attribute.type.toSql();
      template += ` CHECK (${this.quoteIdentifier(attribute.field)} IN(${attribute.values.map((value) => {
        return this.escape(value);
      }).join(", ")}))`;
    } else {
      template = attribute.type.toString();
    }
    if (options && options.context === "changeColumn" && attribute.type) {
      template = `DATA TYPE ${template}`;
    } else if (attribute.allowNull === false || attribute.primaryKey === true || attribute.unique) {
      template += " NOT NULL";
      changeNull = 0;
    }
    if (attribute.autoIncrement) {
      let initialValue = 1;
      if (attribute.initialAutoIncrement) {
        initialValue = attribute.initialAutoIncrement;
      }
      template += ` GENERATED BY DEFAULT AS IDENTITY(START WITH ${initialValue}, INCREMENT BY 1)`;
    }
    if (attribute.type !== "TEXT" && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {
      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;
    }
    if (attribute.unique === true) {
      template += " UNIQUE";
    }
    if (attribute.primaryKey) {
      template += " PRIMARY KEY";
    }
    if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {
      if (options && options.context === "addColumn" && options.foreignKey) {
        const attrName = this.quoteIdentifier(options.foreignKey);
        const fkName = `${options.tableName}_${attrName}_fidx`;
        template += `, CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;
      }
      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;
      if (attribute.references.key) {
        template += ` (${this.quoteIdentifier(attribute.references.key)})`;
      } else {
        template += ` (${this.quoteIdentifier("id")})`;
      }
      if (attribute.onDelete) {
        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;
      }
      if (attribute.onUpdate && attribute.onUpdate.toUpperCase() != "CASCADE") {
        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;
      }
    }
    if (options && options.context === "changeColumn" && changeNull === 1 && attribute.allowNull !== void 0) {
      template = [template];
      if (attribute.allowNull) {
        template.push("DROP NOT NULL");
      } else {
        template.push("NOT NULL");
      }
    }
    if (attribute.comment && typeof attribute.comment === "string") {
      template += ` COMMENT ${attribute.comment}`;
    }
    return template;
  }
  attributesToSQL(attributes, options) {
    const result = {}, existingConstraints = [];
    let key, attribute;
    for (key in attributes) {
      attribute = attributes[key];
      if (attribute.references) {
        if (existingConstraints.indexOf(attribute.references.model.toString()) !== -1) {
          attribute.onDelete = "";
          attribute.onUpdate = "";
        } else if (attribute.unique && attribute.unique === true) {
          attribute.onDelete = "";
          attribute.onUpdate = "";
        } else {
          existingConstraints.push(attribute.references.model.toString());
        }
      }
      if (key && !attribute.field && typeof attribute === "object")
        attribute.field = key;
      result[attribute.field || key] = this.attributeToSQL(attribute, options);
    }
    return result;
  }
  createTrigger() {
    throwMethodUndefined("createTrigger");
  }
  dropTrigger() {
    throwMethodUndefined("dropTrigger");
  }
  renameTrigger() {
    throwMethodUndefined("renameTrigger");
  }
  createFunction() {
    throwMethodUndefined("createFunction");
  }
  dropFunction() {
    throwMethodUndefined("dropFunction");
  }
  renameFunction() {
    throwMethodUndefined("renameFunction");
  }
  _getForeignKeysQuerySQL(condition) {
    return `SELECT R.CONSTNAME AS "constraintName", TRIM(R.TABSCHEMA) AS "constraintSchema", R.TABNAME AS "tableName", TRIM(R.TABSCHEMA) AS "tableSchema", LISTAGG(C.COLNAME,', ') WITHIN GROUP (ORDER BY C.COLNAME) AS "columnName", TRIM(R.REFTABSCHEMA) AS "referencedTableSchema", R.REFTABNAME AS "referencedTableName", TRIM(R.PK_COLNAMES) AS "referencedColumnName" FROM SYSCAT.REFERENCES R, SYSCAT.KEYCOLUSE C WHERE R.CONSTNAME = C.CONSTNAME AND R.TABSCHEMA = C.TABSCHEMA AND R.TABNAME = C.TABNAME${condition} GROUP BY R.REFTABSCHEMA, R.REFTABNAME, R.TABSCHEMA, R.TABNAME, R.CONSTNAME, R.PK_COLNAMES`;
  }
  getForeignKeysQuery(table, schemaName) {
    const tableName = table.tableName || table;
    schemaName = table.schema || schemaName;
    let sql = "";
    if (tableName) {
      sql = ` AND R.TABNAME = ${wrapSingleQuote(tableName)}`;
    }
    if (schemaName) {
      sql += ` AND R.TABSCHEMA = ${wrapSingleQuote(schemaName)}`;
    }
    return this._getForeignKeysQuerySQL(sql);
  }
  getForeignKeyQuery(table, columnName) {
    const tableName = table.tableName || table;
    const schemaName = table.schema;
    let sql = "";
    if (tableName) {
      sql = ` AND R.TABNAME = ${wrapSingleQuote(tableName)}`;
    }
    if (schemaName) {
      sql += ` AND R.TABSCHEMA = ${wrapSingleQuote(schemaName)}`;
    }
    if (columnName) {
      sql += ` AND C.COLNAME = ${wrapSingleQuote(columnName)}`;
    }
    return this._getForeignKeysQuerySQL(sql);
  }
  getPrimaryKeyConstraintQuery(table, attributeName) {
    const tableName = wrapSingleQuote(table.tableName || table);
    return [
      'SELECT TABNAME AS "tableName",',
      'COLNAME AS "columnName",',
      'CONSTNAME AS "constraintName"',
      "FROM SYSCAT.KEYCOLUSE WHERE CONSTNAME LIKE 'PK_%'",
      `AND COLNAME = ${wrapSingleQuote(attributeName)}`,
      `AND TABNAME = ${tableName};`
    ].join(" ");
  }
  dropForeignKeyQuery(tableName, foreignKey) {
    return _.template("ALTER TABLE <%= table %> DROP <%= key %>", this._templateSettings)({
      table: this.quoteTable(tableName),
      key: this.quoteIdentifier(foreignKey)
    });
  }
  dropConstraintQuery(tableName, constraintName) {
    const sql = "ALTER TABLE <%= table %> DROP CONSTRAINT <%= constraint %>;";
    return _.template(sql, this._templateSettings)({
      table: this.quoteTable(tableName),
      constraint: this.quoteIdentifier(constraintName)
    });
  }
  setAutocommitQuery() {
    return "";
  }
  setIsolationLevelQuery() {
  }
  generateTransactionId() {
    return randomBytes(10).toString("hex");
  }
  startTransactionQuery(transaction) {
    if (transaction.parent) {
      return `SAVE TRANSACTION ${this.quoteIdentifier(transaction.name)};`;
    }
    return "BEGIN TRANSACTION;";
  }
  commitTransactionQuery(transaction) {
    if (transaction.parent) {
      return;
    }
    return "COMMIT TRANSACTION;";
  }
  rollbackTransactionQuery(transaction) {
    if (transaction.parent) {
      return `ROLLBACK TRANSACTION ${this.quoteIdentifier(transaction.name)};`;
    }
    return "ROLLBACK TRANSACTION;";
  }
  addLimitAndOffset(options) {
    const offset = options.offset || 0;
    let fragment = "";
    if (offset > 0) {
      fragment += ` OFFSET ${this.escape(offset)} ROWS`;
    }
    if (options.limit) {
      fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;
    }
    return fragment;
  }
  booleanValue(value) {
    return value ? 1 : 0;
  }
  addUniqueFields(dataValues, rawAttributes, uniqno) {
    uniqno = uniqno === void 0 ? 1 : uniqno;
    for (const key in rawAttributes) {
      if (rawAttributes[key].unique && dataValues[key] === void 0) {
        if (rawAttributes[key].type instanceof DataTypes.DATE) {
          dataValues[key] = Utils.now("db2");
        } else if (rawAttributes[key].type instanceof DataTypes.STRING) {
          dataValues[key] = `unique${uniqno++}`;
        } else if (rawAttributes[key].type instanceof DataTypes.INTEGER) {
          dataValues[key] = uniqno++;
        } else if (rawAttributes[key].type instanceof DataTypes.BOOLEAN) {
          dataValues[key] = new DataTypes.BOOLEAN(false);
        }
      }
    }
    return uniqno;
  }
  quoteIdentifier(identifier, force) {
    return Utils.addTicks(Utils.removeTicks(identifier, '"'), '"');
  }
}
function wrapSingleQuote(identifier) {
  if (identifier) {
    return `'${identifier}'`;
  }
  return "";
}
module.exports = Db2QueryGenerator;
//# sourceMappingURL=query-generator.js.map
