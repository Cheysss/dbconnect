/**
 * @module LRUCache
 */
declare const TYPE: unique symbol;
export type PosInt = number & {
    [TYPE]: 'Positive Integer';
};
export type Index = number & {
    [TYPE]: 'LRUCache Index';
};
export type UintArray = Uint8Array | Uint16Array | Uint32Array;
export type NumberArray = UintArray | number[];
declare class ZeroArray extends Array<number> {
    constructor(size: number);
}
export type { ZeroArray };
export type { Stack };
export type StackLike = Stack | Index[];
declare class Stack {
    #private;
    heap: NumberArray;
    length: number;
    static create(max: number): StackLike;
    constructor(max: number, HeapCls: {
        new (n: number): NumberArray;
    });
    push(n: Index): void;
    pop(): Index;
}
/**
 * Promise representing an in-progress {@link LRUCache#fetch} call
 */
export type BackgroundFetch<V> = Promise<V | undefined> & {
    __returned: BackgroundFetch<V> | undefined;
    __abortController: AbortController;
    __staleWhileFetching: V | undefined;
};
export type DisposeTask<K, V> = [
    value: V,
    key: K,
    reason: LRUCache.DisposeReason
];
export declare namespace LRUCache {
    /**
     * An integer greater than 0, reflecting the calculated size of items
     */
    type Size = number;
    /**
     * Integer greater than 0, representing some number of milliseconds, or the
     * time at which a TTL started counting from.
     */
    type Milliseconds = number;
    /**
     * An integer greater than 0, reflecting a number of items
     */
    type Count = number;
    /**
     * The reason why an item was removed from the cache, passed
     * to the {@link Disposer} methods.
     *
     * - `evict`: The item was evicted because it is the least recently used,
     *   and the cache is full.
     * - `set`: A new value was set, overwriting the old value being disposed.
     * - `delete`: The item was explicitly deleted, either by calling
     *   {@link LRUCache#delete}, {@link LRUCache#clear}, or
     *   {@link LRUCache#set} with an undefined value.
     * - `expire`: The item was removed due to exceeding its TTL.
     * - `fetch`: A {@link OptionsBase#fetchMethod} operation returned
     *   `undefined` or was aborted, causing the item to be deleted.
     */
    type DisposeReason = 'evict' | 'set' | 'delete' | 'expire' | 'fetch';
    /**
     * A method called upon item removal, passed as the
     * {@link OptionsBase.dispose} and/or
     * {@link OptionsBase.disposeAfter} options.
     */
    type Disposer<K, V> = (value: V, key: K, reason: DisposeReason) => void;
    /**
     * A function that returns the effective calculated size
     * of an entry in the cache.
     */
    type SizeCalculator<K, V> = (value: V, key: K) => Size;
    /**
     * Options provided to the
     * {@link OptionsBase.fetchMethod} function.
     */
    interface FetcherOptions<K, V, FC = unknown> {
        signal: AbortSignal;
        options: FetcherFetchOptions<K, V, FC>;
        /**
         * Object provided in the {@link FetchOptions.context} option to
         * {@link LRUCache#fetch}
         */
        context: FC;
    }
    /**
     * Occasionally, it may be useful to track the internal behavior of the
     * cache, particularly for logging, debugging, or for behavior within the
     * `fetchMethod`. To do this, you can pass a `status` object to the
     * {@link LRUCache#fetch}, {@link LRUCache#get}, {@link LRUCache#set},
     * {@link LRUCache#memo}, and {@link LRUCache#has} methods.
     *
     * The `status` option should be a plain JavaScript object. The following
     * fields will be set on it appropriately, depending on the situation.
     */
    interface Status<V> {
        /**
         * The status of a set() operation.
         *
         * - add: the item was not found in the cache, and was added
         * - update: the item was in the cache, with the same value provided
         * - replace: the item was in the cache, and replaced
         * - miss: the item was not added to the cache for some reason
         */
        set?: 'add' | 'update' | 'replace' | 'miss';
        /**
         * the ttl stored for the item, or undefined if ttls are not used.
         */
        ttl?: Milliseconds;
        /**
         * the start time for the item, or undefined if ttls are not used.
         */
        start?: Milliseconds;
        /**
         * The timestamp used for TTL calculation
         */
        now?: Milliseconds;
        /**
         * the remaining ttl for the item, or undefined if ttls are not used.
         */
        remainingTTL?: Milliseconds;
        /**
         * The calculated size for the item, if sizes are used.
         */
        entrySize?: Size;
        /**
         * The total calculated size of the cache, if sizes are used.
         */
        totalCalculatedSize?: Size;
        /**
         * A flag indicating that the item was not stored, due to exceeding the
         * {@link OptionsBase.maxEntrySize}
         */
        maxEntrySizeExceeded?: true;
        /**
         * The old value, specified in the case of `set:'update'` or
         * `set:'replace'`
         */
        oldValue?: V;
        /**
         * The results of a {@link LRUCache#has} operation
         *
         * - hit: the item was found in the cache
         * - stale: the item was found in the cache, but is stale
         * - miss: the item was not found in the cache
         */
        has?: 'hit' | 'stale' | 'miss';
        /**
         * The status of a {@link LRUCache#fetch} operation.
         * Note that this can change as the underlying fetch() moves through
         * various states.
         *
         * - inflight: there is another fetch() for this key which is in process
         * - get: there is no {@link OptionsBase.fetchMethod}, so
         *   {@link LRUCache#get} was called.
         * - miss: the item is not in cache, and will be fetched.
         * - hit: the item is in the cache, and was resolved immediately.
         * - stale: the item is in the cache, but stale.
         * - refresh: the item is in the cache, and not stale, but
         *   {@link FetchOptions.forceRefresh} was specified.
         */
        fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh';
        /**
         * The {@link OptionsBase.fetchMethod} was called
         */
        fetchDispatched?: true;
        /**
         * The cached value was updated after a successful call to
         * {@link OptionsBase.fetchMethod}
         */
        fetchUpdated?: true;
        /**
         * The reason for a fetch() rejection.  Either the error raised by the
         * {@link OptionsBase.fetchMethod}, or the reason for an
         * AbortSignal.
         */
        fetchError?: Error;
        /**
         * The fetch received an abort signal
         */
        fetchAborted?: true;
        /**
         * The abort signal received was ignored, and the fetch was allowed to
         * continue.
         */
        fetchAbortIgnored?: true;
        /**
         * The fetchMethod promise resolved successfully
         */
        fetchResolved?: true;
        /**
         * The fetchMethod promise was rejected
         */
        fetchRejected?: true;
        /**
         * The status of a {@link LRUCache#get} operation.
         *
         * - fetching: The item is currently being fetched.  If a previous value
         *   is present and allowed, that will be returned.
         * - stale: The item is in the cache, and is stale.
         * - hit: the item is in the cache
         * - miss: the item is not in the cache
         */
        get?: 'stale' | 'hit' | 'miss';
        /**
         * A fetch or get operation returned a stale value.
         */
        returnedStale?: true;
    }
    /**
     * options which override the options set in the LRUCache constructor
     * when calling {@link LRUCache#fetch}.
     *
     * This is the union of {@link GetOptions} and {@link SetOptions}, plus
     * {@link OptionsBase.noDeleteOnFetchRejection},
     * {@link OptionsBase.allowStaleOnFetchRejection},
     * {@link FetchOptions.forceRefresh}, and
     * {@link FetcherOptions.context}
     *
     * Any of these may be modified in the {@link OptionsBase.fetchMethod}
     * function, but the {@link GetOptions} fields will of course have no
     * effect, as the {@link LRUCache#get} call already happened by the time
     * the fetchMethod is called.
     */
    interface FetcherFetchOptions<K, V, FC = unknown> extends Pick<OptionsBase<K, V, FC>, 'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet' | 'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL' | 'noDeleteOnFetchRejection' | 'allowStaleOnFetchRejection' | 'ignoreFetchAbort' | 'allowStaleOnFetchAbort'> {
        status?: Status<V>;
        size?: Size;
    }
    /**
     * Options that may be passed to the {@link LRUCache#fetch} method.
     */
    interface FetchOptions<K, V, FC> extends FetcherFetchOptions<K, V, FC> {
        /**
         * Set to true to force a re-load of the existing data, even if it
         * is not yet stale.
         */
        forceRefresh?: boolean;
        /**
         * Context provided to the {@link OptionsBase.fetchMethod} as
         * the {@link FetcherOptions.context} param.
         *
         * If the FC type is specified as unknown (the default),
         * undefined or void, then this is optional.  Otherwise, it will
         * be required.
         */
        context?: FC;
        signal?: AbortSignal;
        status?: Status<V>;
    }
    /**
     * Options provided to {@link LRUCache#fetch} when the FC type is something
     * other than `unknown`, `undefined`, or `void`
     */
    interface FetchOptionsWithContext<K, V, FC> extends FetchOptions<K, V, FC> {
        context: FC;
    }
    /**
     * Options provided to {@link LRUCache#fetch} when the FC type is
     * `undefined` or `void`
     */
    interface FetchOptionsNoContext<K, V> extends FetchOptions<K, V, undefined> {
        context?: undefined;
    }
    interface MemoOptions<K, V, FC = unknown> extends Pick<OptionsBase<K, V, FC>, 'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet' | 'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL' | 'noDeleteOnFetchRejection' | 'allowStaleOnFetchRejection' | 'ignoreFetchAbort' | 'allowStaleOnFetchAbort'> {
        /**
         * Set to true to force a re-load of the existing data, even if it
         * is not yet stale.
         */
        forceRefresh?: boolean;
        /**
         * Context provided to the {@link OptionsBase.memoMethod} as
         * the {@link MemoizerOptions.context} param.
         *
         * If the FC type is specified as unknown (the default),
         * undefined or void, then this is optional.  Otherwise, it will
         * be required.
         */
        context?: FC;
        status?: Status<V>;
    }
    /**
     * Options provided to {@link LRUCache#memo} when the FC type is something
     * other than `unknown`, `undefined`, or `void`
     */
    interface MemoOptionsWithContext<K, V, FC> extends MemoOptions<K, V, FC> {
        context: FC;
    }
    /**
     * Options provided to {@link LRUCache#memo} when the FC type is
     * `undefined` or `void`
     */
    interface MemoOptionsNoContext<K, V> extends MemoOptions<K, V, undefined> {
        context?: undefined;
    }
    /**
     * Options provided to the
     * {@link OptionsBase.memoMethod} function.
     */
    interface MemoizerOptions<K, V, FC = unknown> {
        options: MemoizerMemoOptions<K, V, FC>;
        /**
         * Object provided in the {@link MemoOptions.context} option to
         * {@link LRUCache#memo}
         */
        context: FC;
    }
    /**
     * options which override the options set in the LRUCache constructor
     * when calling {@link LRUCache#memo}.
     *
     * This is the union of {@link GetOptions} and {@link SetOptions}, plus
     * {@link MemoOptions.forceRefresh}, and
     * {@link MemoerOptions.context}
     *
     * Any of these may be modified in the {@link OptionsBase.memoMethod}
     * function, but the {@link GetOptions} fields will of course have no
     * effect, as the {@link LRUCache#get} call already happened by the time
     * the memoMethod is called.
     */
    interface MemoizerMemoOptions<K, V, FC = unknown> extends Pick<OptionsBase<K, V, FC>, 'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet' | 'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'> {
        status?: Status<V>;
        size?: Size;
        start?: Milliseconds;
    }
    /**
     * Options that may be passed to the {@link LRUCache#has} method.
     */
    interface HasOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'updateAgeOnHas'> {
        status?: Status<V>;
    }
    /**
     * Options that may be passed to the {@link LRUCache#get} method.
     */
    interface GetOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet'> {
        status?: Status<V>;
    }
    /**
     * Options that may be passed to the {@link LRUCache#peek} method.
     */
    interface PeekOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'allowStale'> {
    }
    /**
     * Options that may be passed to the {@link LRUCache#set} method.
     */
    interface SetOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'> {
        /**
         * If size tracking is enabled, then setting an explicit size
         * in the {@link LRUCache#set} call will prevent calling the
         * {@link OptionsBase.sizeCalculation} function.
         */
        size?: Size;
        /**
         * If TTL tracking is enabled, then setting an explicit start
         * time in the {@link LRUCache#set} call will override the
         * default time from `performance.now()` or `Date.now()`.
         *
         * Note that it must be a valid value for whichever time-tracking
         * method is in use.
         */
        start?: Milliseconds;
        status?: Status<V>;
    }
    /**
     * The type signature for the {@link OptionsBase.fetchMethod} option.
     */
    type Fetcher<K, V, FC = unknown> = (key: K, staleValue: V | undefined, options: FetcherOptions<K, V, FC>) => Promise<V | undefined | void> | V | undefined | void;
    /**
     * the type signature for the {@link OptionsBase.memoMethod} option.
     */
    type Memoizer<K, V, FC = unknown> = (key: K, staleValue: V | undefined, options: MemoizerOptions<K, V, FC>) => V;
    /**
     * Options which may be passed to the {@link LRUCache} constructor.
     *
     * Most of these may be overridden in the various options that use
     * them.
     *
     * Despite all being technically optional, the constructor requires that
     * a cache is at minimum limited by one or more of {@link OptionsBase.max},
     * {@link OptionsBase.ttl}, or {@link OptionsBase.maxSize}.
     *
     * If {@link OptionsBase.ttl} is used alone, then it is strongly advised
     * (and in fact required by the type definitions here) that the cache
     * also set {@link OptionsBase.ttlAutopurge}, to prevent potentially
     * unbounded storage.
     *
     * All options are also available on the {@link LRUCache} instance, making
     * it safe to pass an LRUCache instance as the options argumemnt to
     * make another empty cache of the same type.
     *
     * Some options are marked as read-only, because changing them after
     * instantiation is not safe. Changing any of the other options will of
     * course only have an effect on subsequent method calls.
     */
    interface OptionsBase<K, V, FC> {
        /**
         * The maximum number of items to store in the cache before evicting
         * old entries. This is read-only on the {@link LRUCache} instance,
         * and may not be overridden.
         *
         * If set, then storage space will be pre-allocated at construction
         * time, and the cache will perform significantly faster.
         *
         * Note that significantly fewer items may be stored, if
         * {@link OptionsBase.maxSize} and/or {@link OptionsBase.ttl} are also
         * set.
         *
         * **It is strongly recommended to set a `max` to prevent unbounded growth
         * of the cache.**
         */
        max?: Count;
        /**
         * Max time in milliseconds for items to live in cache before they are
         * considered stale.  Note that stale items are NOT preemptively removed by
         * default, and MAY live in the cache, contributing to its LRU max, long
         * after they have expired, unless {@link OptionsBase.ttlAutopurge} is
         * set.
         *
         * If set to `0` (the default value), then that means "do not track
         * TTL", not "expire immediately".
         *
         * Also, as this cache is optimized for LRU/MRU operations, some of
         * the staleness/TTL checks will reduce performance, as they will incur
         * overhead by deleting items.
         *
         * This is not primarily a TTL cache, and does not make strong TTL
         * guarantees. There is no pre-emptive pruning of expired items, but you
         * _may_ set a TTL on the cache, and it will treat expired items as missing
         * when they are fetched, and delete them.
         *
         * Optional, but must be a non-negative integer in ms if specified.
         *
         * This may be overridden by passing an options object to `cache.set()`.
         *
         * At least one of `max`, `maxSize`, or `TTL` is required. This must be a
         * positive integer if set.
         *
         * Even if ttl tracking is enabled, **it is strongly recommended to set a
         * `max` to prevent unbounded growth of the cache.**
         *
         * If ttl tracking is enabled, and `max` and `maxSize` are not set,
         * and `ttlAutopurge` is not set, then a warning will be emitted
         * cautioning about the potential for unbounded memory consumption.
         * (The TypeScript definitions will also discourage this.)
         */
        ttl?: Milliseconds;
        /**
         * Minimum amount of time in ms in which to check for staleness.
         * Defaults to 1, which means that the current time is checked
         * at most once per millisecond.
         *
         * Set to 0 to check the current time every time staleness is tested.
         * (This reduces performance, and is theoretically unnecessary.)
         *
         * Setting this to a higher value will improve performance somewhat
         * while using ttl tracking, albeit at the expense of keeping stale
         * items around a bit longer than their TTLs would indicate.
         *
         * @default 1
         */
        ttlResolution?: Milliseconds;
        /**
         * Preemptively remove stale items from the cache.
         *
         * Note that this may *significantly* degrade performance, especially if
         * the cache is storing a large number of items. It is almost always best
         * to just leave the stale items in the cache, and let them fall out as new
         * items are added.
         *
         * Note that this means that {@link OptionsBase.allowStale} is a bit
         * pointless, as stale items will be deleted almost as soon as they
         * expire.
         *
         * Use with caution!
         */
        ttlAutopurge?: boolean;
        /**
         * When using time-expiring entries with `ttl`, setting this to `true` will
         * make each item's age reset to 0 whenever it is retrieved from cache with
         * {@link LRUCache#get}, causing it to not expire. (It can still fall out
         * of cache based on recency of use, of course.)
         *
         * Has no effect if {@link OptionsBase.ttl} is not set.
         *
         * This may be overridden by passing an options object to `cache.get()`.
         */
        updateAgeOnGet?: boolean;
        /**
         * When using time-expiring entries with `ttl`, setting this to `true` will
         * make each item's age reset to 0 whenever its presence in the cache is
         * checked with {@link LRUCache#has}, causing it to not expire. (It can
         * still fall out of cache based on recency of use, of course.)
         *
         * Has no effect if {@link OptionsBase.ttl} is not set.
         */
        updateAgeOnHas?: boolean;
        /**
         * Allow {@link LRUCache#get} and {@link LRUCache#fetch} calls to return
         * stale data, if available.
         *
         * By default, if you set `ttl`, stale items will only be deleted from the
         * cache when you `get(key)`. That is, it's not preemptively pruning items,
         * unless {@link OptionsBase.ttlAutopurge} is set.
         *
         * If you set `allowStale:true`, it'll return the stale value *as well as*
         * deleting it. If you don't set this, then it'll return `undefined` when
         * you try to get a stale entry.
         *
         * Note that when a stale entry is fetched, _even if it is returned due to
         * `allowStale` being set_, it is removed from the cache immediately. You
         * can suppress this behavior by setting
         * {@link OptionsBase.noDeleteOnStaleGet}, either in the constructor, or in
         * the options provided to {@link LRUCache#get}.
         *
         * This may be overridden by passing an options object to `cache.get()`.
         * The `cache.has()` method will always return `false` for stale items.
         *
         * Only relevant if a ttl is set.
         */
        allowStale?: boolean;
        /**
         * Function that is called on items when they are dropped from the
         * cache, as `dispose(value, key, reason)`.
         *
         * This can be handy if you want to close file descriptors or do
         * other cleanup tasks when items are no longer stored in the cache.
         *
         * **NOTE**: It is called _before_ the item has been fully removed
         * from the cache, so if you want to put it right back in, you need
         * to wait until the next tick. If you try to add it back in during
         * the `dispose()` function call, it will break things in subtle and
         * weird ways.
         *
         * Unlike several other options, this may _not_ be overridden by
         * passing an option to `set()`, for performance reasons.
         *
         * The `reason` will be one of the following strings, corresponding
         * to the reason for the item's deletion:
         *
         * - `evict` Item was evicted to make space for a new addition
         * - `set` Item was overwritten by a new value
         * - `expire` Item expired its TTL
         * - `fetch` Item was deleted due to a failed or aborted fetch, or a
         *   fetchMethod returning `undefined.
         * - `delete` Item was removed by explicit `cache.delete(key)`,
         *   `cache.clear()`, or `cache.set(key, undefined)`.
         */
        dispose?: Disposer<K, V>;
        /**
         * The same as {@link OptionsBase.dispose}, but called *after* the entry
         * is completely removed and the cache is once again in a clean state.
         *
         * It is safe to add an item right back into the cache at this point.
         * However, note that it is *very* easy to inadvertently create infinite
         * recursion this way.
         */
        disposeAfter?: Disposer<K, V>;
        /**
         * Set to true to suppress calling the
         * {@link OptionsBase.dispose} function if the entry key is
         * still accessible within the cache.
         *
         * This may be overridden by passing an options object to
         * {@link LRUCache#set}.
         *
         * Only relevant if `dispose` or `disposeAfter` are set.
         */
        noDisposeOnSet?: boolean;
        /**
         * Boolean flag to tell the cache to not update the TTL when setting a new
         * value for an existing key (ie, when updating a value rather than
         * inserting a new value).  Note that the TTL value is _always_ set (if
         * provided) when adding a new entry into the cache.
         *
         * Has no effect if a {@link OptionsBase.ttl} is not set.
         *
         * May be passed as an option to {@link LRUCache#set}.
         */
        noUpdateTTL?: boolean;
        /**
         * Set to a positive integer to track the sizes of items added to the
         * cache, and automatically evict items in order to stay below this size.
         * Note that this may result in fewer than `max` items being stored.
         *
         * Attempting to add an item to the cache whose calculated size is greater
         * that this amount will be a no-op. The item will not be cached, and no
         * other items will be evicted.
         *
         * Optional, must be a positive integer if provided.
         *
         * Sets `maxEntrySize` to the same value, unless a different value is
         * provided for `maxEntrySize`.
         *
         * At least one of `max`, `maxSize`, or `TTL` is required. This must be a
         * positive integer if set.
         *
         * Even if size tracking is enabled, **it is strongly recommended to set a
         * `max` to prevent unbounded growth of the cache.**
         *
         * Note also that size tracking can negatively impact performance,
         * though for most cases, only minimally.
         */
        maxSize?: Size;
        /**
         * The maximum allowed size for any single item in the cache.
         *
         * If a larger item is passed to {@link LRUCache#set} or returned by a
         * {@link OptionsBase.fetchMethod} or {@link OptionsBase.memoMethod}, then
         * it will not be stored in the cache.
         *
         * Attempting to add an item whose calculated size is greater than
         * this amount will not cache the item or evict any old items, but
         * WILL delete an existing value if one is already present.
         *
         * Optional, must be a positive integer if provided. Defaults to
         * the value of `maxSize` if provided.
         */
        maxEntrySize?: Size;
        /**
         * A function that returns a number indicating the item's size.
         *
         * Requires {@link OptionsBase.maxSize} to be set.
         *
         * If not provided, and {@link OptionsBase.maxSize} or
         * {@link OptionsBase.maxEntrySize} are set, then all
         * {@link LRUCache#set} calls **must** provide an explicit
         * {@link SetOptions.size} or sizeCalculation param.
         */
        sizeCalculation?: SizeCalculator<K, V>;
        /**
         * Method that provides the implementation for {@link LRUCache#fetch}
         *
         * ```ts
         * fetchMethod(key, staleValue, { signal, options, context })
         * ```
         *
         * If `fetchMethod` is not provided, then `cache.fetch(key)` is equivalent
         * to `Promise.resolve(cache.get(key))`.
         *
         * If at any time, `signal.aborted` is set to `true`, or if the
         * `signal.onabort` method is called, or if it emits an `'abort'` event
         * which you can listen to with `addEventListener`, then that means that
         * the fetch should be abandoned. This may be passed along to async
         * functions aware of AbortController/AbortSignal behavior.
         *
         * The `fetchMethod` should **only** return `undefined` or a Promise
         * resolving to `undefined` if the AbortController signaled an `abort`
         * event. In all other cases, it should return or resolve to a value
         * suitable for adding to the cache.
         *
         * The `options` object is a union of the options that may be provided to
         * `set()` and `get()`. If they are modified, then that will result in
         * modifying the settings to `cache.set()` when the value is resolved, and
         * in the case of
         * {@link OptionsBase.noDeleteOnFetchRejection} and
         * {@link OptionsBase.allowStaleOnFetchRejection}, the handling of
         * `fetchMethod` failures.
         *
         * For example, a DNS cache may update the TTL based on the value returned
         * from a remote DNS server by changing `options.ttl` in the `fetchMethod`.
         */
        fetchMethod?: Fetcher<K, V, FC>;
        /**
         * Method that provides the implementation for {@link LRUCache#memo}
         */
        memoMethod?: Memoizer<K, V, FC>;
        /**
         * Set to true to suppress the deletion of stale data when a
         * {@link OptionsBase.fetchMethod} returns a rejected promise.
         */
        noDeleteOnFetchRejection?: boolean;
        /**
         * Do not delete stale items when they are retrieved with
         * {@link LRUCache#get}.
         *
         * Note that the `get` return value will still be `undefined`
         * unless {@link OptionsBase.allowStale} is true.
         *
         * When using time-expiring entries with `ttl`, by default stale
         * items will be removed from the cache when the key is accessed
         * with `cache.get()`.
         *
         * Setting this option will cause stale items to remain in the cache, until
         * they are explicitly deleted with `cache.delete(key)`, or retrieved with
         * `noDeleteOnStaleGet` set to `false`.
         *
         * This may be overridden by passing an options object to `cache.get()`.
         *
         * Only relevant if a ttl is used.
         */
        noDeleteOnStaleGet?: boolean;
        /**
         * Set to true to allow returning stale data when a
         * {@link OptionsBase.fetchMethod} throws an error or returns a rejected
         * promise.
         *
         * This differs from using {@link OptionsBase.allowStale} in that stale
         * data will ONLY be returned in the case that the {@link LRUCache#fetch}
         * fails, not any other times.
         *
         * If a `fetchMethod` fails, and there is no stale value available, the
         * `fetch()` will resolve to `undefined`. Ie, all `fetchMethod` errors are
         * suppressed.
         *
         * Implies `noDeleteOnFetchRejection`.
         *
         * This may be set in calls to `fetch()`, or defaulted on the constructor,
         * or overridden by modifying the options object in the `fetchMethod`.
         */
        allowStaleOnFetchRejection?: boolean;
        /**
         * Set to true to return a stale value from the cache when the
         * `AbortSignal` passed to the {@link OptionsBase.fetchMethod} dispatches
         * an `'abort'` event, whether user-triggered, or due to internal cache
         * behavior.
         *
         * Unless {@link OptionsBase.ignoreFetchAbort} is also set, the underlying
         * {@link OptionsBase.fetchMethod} will still be considered canceled, and
         * any value it returns will be ignored and not cached.
         *
         * Caveat: since fetches are aborted when a new value is explicitly
         * set in the cache, this can lead to fetch returning a stale value,
         * since that was the fallback value _at the moment the `fetch()` was
         * initiated_, even though the new updated value is now present in
         * the cache.
         *
         * For example:
         *
         * ```ts
         * const cache = new LRUCache<string, any>({
         *   ttl: 100,
         *   fetchMethod: async (url, oldValue, { signal }) =>  {
         *     const res = await fetch(url, { signal })
         *     return await res.json()
         *   }
         * })
         * cache.set('https://example.com/', { some: 'data' })
         * // 100ms go by...
         * const result = cache.fetch('https://example.com/')
         * cache.set('https://example.com/', { other: 'thing' })
         * console.log(await result) // { some: 'data' }
         * console.log(cache.get('https://example.com/')) // { other: 'thing' }
         * ```
         */
        allowStaleOnFetchAbort?: boolean;
        /**
         * Set to true to ignore the `abort` event emitted by the `AbortSignal`
         * object passed to {@link OptionsBase.fetchMethod}, and still cache the
         * resulting resolution value, as long as it is not `undefined`.
         *
         * When used on its own, this means aborted {@link LRUCache#fetch} calls
         * are not immediately resolved or rejected when they are aborted, and
         * instead take the full time to await.
         *
         * When used with {@link OptionsBase.allowStaleOnFetchAbort}, aborted
         * {@link LRUCache#fetch} calls will resolve immediately to their stale
         * cached value or `undefined`, and will continue to process and eventually
         * update the cache when they resolve, as long as the resulting value is
         * not `undefined`, thus supporting a "return stale on timeout while
         * refreshing" mechanism by passing `AbortSignal.timeout(n)` as the signal.
         *
         * For example:
         *
         * ```ts
         * const c = new LRUCache({
         *   ttl: 100,
         *   ignoreFetchAbort: true,
         *   allowStaleOnFetchAbort: true,
         *   fetchMethod: async (key, oldValue, { signal }) => {
         *     // note: do NOT pass the signal to fetch()!
         *     // let's say this fetch can take a long time.
         *     const res = await fetch(`https://slow-backend-server/${key}`)
         *     return await res.json()
         *   },
         * })
         *
         * // this will return the stale value after 100ms, while still
         * // updating in the background for next time.
         * const val = await c.fetch('key', { signal: AbortSignal.timeout(100) })
         * ```
         *
         * **Note**: regardless of this setting, an `abort` event _is still
         * emitted on the `AbortSignal` object_, so may result in invalid results
         * when passed to other underlying APIs that use AbortSignals.
         *
         * This may be overridden in the {@link OptionsBase.fetchMethod} or the
         * call to {@link LRUCache#fetch}.
         */
        ignoreFetchAbort?: boolean;
    }
    interface OptionsMaxLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        max: Count;
    }
    interface OptionsTTLLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        ttl: Milliseconds;
        ttlAutopurge: boolean;
    }
    interface OptionsSizeLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        maxSize: Size;
    }
    /**
     * The valid safe options for the {@link LRUCache} constructor
     */
    type Options<K, V, FC> = OptionsMaxLimit<K, V, FC> | OptionsSizeLimit<K, V, FC> | OptionsTTLLimit<K, V, FC>;
    /**
     * Entry objects used by {@link LRUCache#load} and {@link LRUCache#dump},
     * and returned by {@link LRUCache#info}.
     */
    interface Entry<V> {
        value: V;
        ttl?: Milliseconds;
        size?: Size;
        start?: Milliseconds;
    }
}
/**
 * Default export, the thing you're using this module to get.
 *
 * The `K` and `V` types define the key and value types, respectively. The
 * optional `FC` type defines the type of the `context` object passed to
 * `cache.fetch()` and `cache.memo()`.
 *
 * Keys and values **must not** be `null` or `undefined`.
 *
 * All properties from the options object (with the exception of `max`,
 * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are
 * added as normal public members. (The listed options are read-only getters.)
 *
 * Changing any of these will alter the defaults for subsequent method calls.
 */
export declare class LRUCache<K extends {}, V extends {}, FC = unknown> implements Map<K, V> {
    #private;
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ttl: LRUCache.Milliseconds;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ttlResolution: LRUCache.Milliseconds;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ttlAutopurge: boolean;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    updateAgeOnGet: boolean;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    updateAgeOnHas: boolean;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    allowStale: boolean;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    noDisposeOnSet: boolean;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    noUpdateTTL: boolean;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    maxEntrySize: LRUCache.Size;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    sizeCalculation?: LRUCache.SizeCalculator<K, V>;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    noDeleteOnFetchRejection: boolean;
 I‹ØL‹úH‹ñA‹üH…Òu
¿W €éÔ  H…ÛtñH‹‰  H…É„º  H‹A·ÖH‹@8ÿ­  „Àt4D8c
u
¿   éš  H‹  A·ÖH‹H‹@8ÿó¬  €KˆCév  H‹  A·ÖH‹H‹@0ÿÏ¬  …ÀtD8c
t°ŠC¨u©ˆCéC  H‹NA·ÖH‹H‹@XÿŸ¬  …À„!  A€r9A¶GHkÈ,BöD9èt(D8c
u"D9ePuH‹  H‹H‹@@ÿ_¬  …À„BÿÿÿöC…8ÿÿÿD8c….ÿÿÿ€{
„$ÿÿÿ¶C
LMôL‰L$0HSD‰eğLMğL‰L$(LM8Dˆe8D‰e@D‰eôfD‰tCH‹ND¶C
L‰L$ AÿÀLM@H‹H‹@ ÿã«  ‹ø…Àxl¶C
ƒÿufD‰dCë[D‹EğLMøşÀH‹ÓˆC
‹E@‰H‹  H‹H‹@(ÿ£«  €cè$ŠMø€áÀá
È‹EôK‰C¶C	A)¶E8ˆC	Aë¿@ €¶C
L\$PI‹sHfD‰dC‹ÇI‹[0I‹ãA_A^A\_]ÃÌÌÌÌÌÌÌÌÌÌÌÌH‰\$H‰l$H‰t$WHƒì 3ÛA‹ğH‹úH‹éH…Òu¸W €ë2…ötõH9™  u¸@ €ë·H‹ÍèFøÿÿ…Àxƒøt
ÿÃHƒÇ;ŞrâH‹\$0H‹l$8H‹t$@HƒÄ _ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌH‰\$H‰l$H‰t$WHƒì 3íH‹ÙH9©  u
¸@ €é7  Š  „Àu
¸W €é#  şÈH±   ¶Àˆ  f‰lA¶  ·”A   H‹Îè:  …Àˆí   ‹ı9«,  vO‹“(  ¶ƒ  ¯×H“@  8Bu
@ˆj@ˆj	ëH¶B;ÁuH‹Ë@ˆjèÃ   …Àˆ   ÿÇ;»,  r±H‹‹  H‹ÖDŠƒ  H‹H‹@ÿÓ©  H‹‹  H‹ÖDŠƒ  ˆƒ  H‹H‹@ÿ¯©  H‹‹  H‹ÖDŠƒ  ˆƒ  H‹H‹@ÿ‹©  …Àx*H‹‹  ¶“  H‹·TSH‹@0ÿg©  ‹ĞH‹Ëè½  H‹\$0H‹l$8H‹t$@HƒÄ _ÃÌÌÌÌÌÌÌÌH‰\$WHƒì Hƒ¹   H‹ÚH‹ùu¸@ €ëH¶BLBàHkÈ,LÁH‹ÏèH   …Àx-¶KşKHkÁ,€|ê uşÉˆKH‹  H‹ÓH‹H‹ ÿ×¨  H‹\$0HƒÄ _ÃÌÌÌÌÌÌÌÌÌÌÌÌH‰\$UVWAVAWH‹ìHƒìPE3ÿI‹ØH‹òL‹ñA‹ÿL9¹  u
¿@ €éô   AŠ@E8xtEˆxë¨t$÷Aˆ@éÕ   A€x
u"A¶@	WÀ)A 3ÀA@I‰@ A‰@(é¬   H‹ILMøE¶@
HSL‰L$0AÿÈD‰}HLMğH‹L‰L$(LM0L‰L$ LMHH‹@ ÿ¨  ‹ø…Àxfƒøu¿ÿÿ €ëZşK
LMô¶C
H‹ÓfD‰|C‹EHD‹Eğ‰I‹  H‹H‹@(ÿÀ§  €cè$ŠMô€áÀá
È‹EøK‰C¶C	)¶E0ˆC	H‹œ$ˆ   ‹ÇHƒÄPA_A^_^]ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ@SHƒì H‹ÙfÇ   Æ  3ÒHƒÁA¸   èu  H‹   3Òè   3ÀHƒÄ [ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌD‹ÚL‹ÉM…Àu¹W €ëTIƒ  E3Ò¹   E9‘,  v?A‹‘(  A¯ÒI‘@  €z uAŠ  8BwE…ÛtAÿËDÑE;‘,  sëÆI‰3É‹ÁÃÌÌÌÌÌÌÌHƒì(H…Òu¸W €HƒÄ(ÃÌA¸   è   HƒÄ(ÃÌÌÌÌÌÌÌÌÌÌÌÌH‰\$A‹ØL‹ÊL‹ÑH…ÒuA¸W €ërH‹3ÉDAH…Àt"I+‚@  A‹Š(  H™H÷ùH‹ÈA;‚,  sËAÈIƒ! E‹š,  A;Ës2A‹’(  ¯ÑI’@  …Ût€z uAŠ‚  8BvAÈëÏE3ÀI‰H‹\$A‹ÀÃÌÌÌÌÌÌÌÌÌÌH‹ÄH‰XH‰hH‰pH‰x AVHƒì H‹òH‹éH…Òu
¹W €éæ   E3öD9±,  †Î   ‹(  A¯ŞH@  €{ …£   Š…  8C‡”   ‹V3ÿÿÂH‹ÎèQ  ‹È…Àx‹F…À„ª   xÿ¯~H~ …Éx}¸   H›€   H¿€   KOC G K°O°CÀGÀKĞOĞCàGàKğOğHƒèu®H‹CH‰GAÿÆD;µ,  ‚2ÿÿÿ3É9N”ÁH‹\$0‹ÁH‹l$8H‹t$@H‹|$HHƒÄ A^ÃÌ¹ÿÿ €ëÛÌÌÌÌÌÌÌH‰\$H‰l$H‰t$WAVAWHƒì 3ÛD‹úH‹ùH9™  u»@ €ëo8™  ug‹ó9™,  v]‹‡(  L‹·@  ¯Æ‹èA8\u:H‹  A‹×H‹H‹@ ÿ.¤  A8D.v‹(  H‹‡@  ¯Î€|tÆDÿÆ;·,  r£H‹l$H‹ÃH‹\$@H‹t$PHƒÄ A_A^_ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ3ÀH…ÒtŠ‰  8J–ÀÃÌÌÌÌÌÌÌÌH‰\$UVWATAUAVAWH‹ìHƒìPE3íE‹ğD‰mXL‹úH‹ñH…Òu
»W €é)  AFÿƒø?wíDˆ±  M‹æfÇ  MäM‹ÌHƒÁM‹Çº€   Hÿ)¢  D  H‹NHUğH‰T$0LMXD‰mğHUôH‰T$(E‹ÆH‹HUHH‰T$ I‹×H‹@ ÿ
£  ‹Ø…À…«   D9mô„¡   ‹–,  H   ÿÂI‹ıèÇ   ‹ØI‹Í…Àx%‹†,  …Àu»ÿÿ €ëpxÿ¯¾(  H¾@  H‹Ï…ÛxX3ÒA¸˜  è^p  ÆGHODˆwM‹Ì¶EHM‹Ç‰º   DˆoHÿX¡  D  €gßDˆw‹EX‰G‹Eğ‰GŠEH€gøˆG‹ÃH‹œ$   HƒÄPA_A^A]A\_^]ÃÌÌÌÌÌÌÌÌÌÌÌH‹IH‹H‹@XHÿ%¢  ÌÌÌÌÌÌH‰\$H‰t$WHƒì H‹ù‹Ú‹I3ö‹G;Ñv0¯ÃH;GvAƒûVGĞ…Òu¾W €ë-H‹Ïè°²ÿÿ‹ğ…Àxë+Ë3Ò¯ÈD‹ÁHiË˜  HO èlo  ‰_H‹\$0‹ÆH‹t$8HƒÄ _ÃÌÌÌÌÌÌÌÌÌ@SHƒì H‹Hƒ! H…Ût$ƒÈÿğÁƒèHKè]F  H‹ËHÿG   D  HƒÄ [ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹AÃÌÌÌÌÌÌÌÌL‹E3ÀM…Òt)D·I
fD9Jw·JJD;Éw·BA‹ÉH+ÈBÆëA¸@ €A‹ÀÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌE3ÉH…ÉuA¹W €ë!M…Àtóƒús‹Â·Af…ÉtfA‰ëA¹   A‹ÁÃÌÌÌÌÌÌÌÌÌÌÌ3ÀH…Éu¸W €ÃÌH…ÒtôˆŠIˆJf‰BÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ·f‰A3ÀÿÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌH‰\$WHƒì ‹ÚH‹ùè,   öÃtH‹ÏHÿŸ  D  H‹\$0H‹ÇHƒÄ _ÃÌÌÌÌÌÌÌÌÌÌ@SHƒì H#–  H‹ÙH‰è 
  HK0H%”  H‰èİßÿÿHKHŠ–  H‰HƒÄ [é$  ÌÌÌÌÌÌÌÌÌÌÌÌÌH‰\$H‰l$VWAVHƒì@3öH‹ÚH‹ùH…Òu
»W €éª  èš	  HOH‹ÓLL$hèu   ‹Ø…ÀˆŠ  ‹T$hƒús
»ÿÿ €éw  H‹O(H,H;é‚a  ‹;ƒ¹  uÛLA9QuÒA‹ ‰GI@I;À‚;  H;Åwº‹HH‰WXH;È‚$  H;Íw£D‹òH‰OPAÁæLñL;ñ‚  L;õw‡‹ÊHë¤  è÷k  H‰G`H…Àu
» €éç   D‹GXD‹ÖD‹ÎE…ÀtKE‹Â@ŠÖ€út%H‹GPA‹Èf94HtAÿÀşÂ€úräëH‹G`A‹ÉˆëH‹G`A‹ÉÆD‹GXAƒÂAÿÁE;ÈrµHO0L;õt/D‹ÍM‹ÆE+ÎèŞÿÿ‹Ø…ÀxpH‹G8H…Àt‹p‹ÆIÆH;ÅtbéÔşÿÿóù  H‹WPóD$0èƒ  ‹Ø…Àx8H‹W8ÇD$h   H…Ò„oşÿÿHJLL$hè6  ‹Ø…Àxƒøué„şÿÿ»€H‹Ïèí  H‹l$p‹ÃH‹\$`HƒÄ@A^_^ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌéÃ  ÌÌÌÌÌÌÌÌÌÌÌHƒì8H‹Hƒd$  H‹@8ÿ™  HƒÄ8ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌH‰\$H‰l$H‰t$ WATAUAVAWHƒì03öE‹ù‹ÚI‹èL‹ñVf;Ús
¾W €é·   A‹FXÂ·Ë;ÈwéH…ítäE…ÉtßI‹VPH…Òu
¾@ €é   Áá¿   ƒéD;ÿABÿL$JI‹×HÒM‹ÄH‹ÍL,?M‹ÍHÿË›  D  A;ÿsNH‹„$€   fB‰t- H…Àt@M‹IƒÈÿ‰t$hIÿÀfC94DuöH‰D$ LL$hI‹B(I‹ÔI‹ÎÿŸœ  f9\$ht
énÿÿÿ¾   H‹\$`‹ÆH‹t$xH‹l$pHƒÄ0A_A^A]A\_ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌHƒì8H‹Hƒd$  H‹@(ÿIœ  HƒÄ8ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌH‰\$WHƒì I‹ùH…ÒuºW €ëXE…ÀtôAƒøwîH…ÿtéH‹\$PH…ÛtÆ HƒÁ0LL$8èL  ‹Ğ…Àx'ƒøtH‹D$8H…Àt·Hf‰H…ÛtŠ@ˆëº   H‹\$0‹ÂHƒÄ _ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌH‰\$H‰t$WHƒì@I‹ñH…Òu
ºW €é†   E…ÀtñAƒøwëH…ötæH‹\$pH…ÛtÜL‹L$xM…ÉtÒH‹¼$€   H…ÿtÅÆ HD$0Aƒ! HƒÁ0ƒ' H‰D$(HD$XH‰D$ èû  ‹Ğ…Àx(ƒøtH‹D$0H…Àt‹L$X‰·Hf‰Š@ˆëº   H‹\$P‹ÂH‹t$`HƒÄ@_ÃÌÌÌÌÌÌÌL‹ÜWATAUAVAWHƒìpIÇC şÿÿÿI‰[I‰kI‰s A‹ÙE‹èL‹âHÄ  I‰C¨IÇC°   E3ÿM‰{¸E‰{ÀM‰{ÈH…Ò„…  AEÿƒø‡x  ƒû	ƒo  H‹¬$À   H…í„^  HƒÁ0MK¨E‹ÅèÅ	  ‹ø…ÀˆI  ‹D$L…Àuxé9  D‹uA‹öE…öu‹ğ‹ĞH‹Íèøÿÿéâ   ƒø†Ù   ‹ğA¯ö‹ÖH‹Íèé÷ÿÿE‹×E‹ŞD;öƒº   ‹ML‹E ‹ÁA¯ÂA¯ËB‹ B‰‹UL‹E ‹ÊA¯ÊA¯Ó‹ÂIPHĞMHLÉ¸   H}AAIJAA B AI0J0AA@B@AIPJPAA`B`HÑAIpJğLÉHƒèu®I‹H‰A‹A‰BABAÿÃA;ÆEÒD#ĞD;Ş‚Fÿÿÿº*   I‹ÌHÿÉ—  D  H…ÀtAMÿ¸*   fA;LDˆ¼$¨   uÆ„$¨    A‹×‰T$ …ö„ò   HkË,H‰L$0L‹L$`‹EA¯ÇHE HƒÁHÈH‰L$(„Â   ‹D$H¯Â‹ØB·Df‰BŠDˆA	Dˆi
M‹ÍMÉHƒÁM‹Äº   Hÿn—  D  L‹D$(AŠP€âß
”$¨   AˆPL‹L$`B‹DA‰@B‹÷ØÉöÑ€á€âø
ÊAˆH‹UA¯×H‹M A¶@	
E…öt3ÒA‹ÇA÷öAFÿ;Ğu‹T$ ÿÂ‰T$ ë‹T$ AÿÇD;şH‹L$0‚#ÿÿÿë¿W €HL$@èä  ‹ÇL\$pI‹[0I‹k@I‹sHI‹ãA_A^A]A\_ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌH‹ÄH‰XH‰hH‰pH‰x AVHƒì@WÀM‹ñA‹ØH‹úH‹é@èE…ÀtH…Òu…Û…  M…ö„  H‹I8H…Éu3Àë·A
·À9D$p‚ò   H…Ét·Af‰D$8·Q
ë3Ò·Â·ÊH7  ‰D$<è?d  H‰D$0H…À„Ñ   D‹D$<3ÒH‹ÈèĞd  H‹m8H…í„œ   …Ût	H…ÿ„   3À3ö…Ût3D·H‹Õ‹ÀHE   HÈH    HÍèxØÿÿƒøÿt3ÿÆHƒÇ;órÍ‹ÀLL$0H‹ÕHE   HÈH    HÍè|  …Àx+D‹L$<E3ÀE…ÉtH‹T$0D;D$psAŠC0AÿÀE;ÁréëH‹T$0H…ÒtH‹ÊHÿ–  D  H‹\$P3ÀH‹l$XH‹t$`H‹|$hHƒÄ@A^ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹AXE3ÀÁàƒÀ…ÒtH‹I8H…ÉtD‹AAÀÃÌÌÌÌÌÌÌH‰\$WHƒì Hƒy H‹Ùu)H‹yPH…ÿt Hÿ’  D  L‹Ç3ÒH‹ÈHÿX“  D  HƒcP HK0ƒcX è¡ÕÿÿHKèØ  H‹K`H…ÉtHÿX•  D  Hƒc` H‹\$0HƒÄ _ÃÌÌÌÌÌÌÌÌÌÌÌD·Ê3ÀAQÿ…Òy¸W €ÃÌ9QXvôH‹I`B¶T	ÿA‰ÃÌÌÌÌÌÌÌÌH‰\$H‰l$ VWATAVAWHƒì`H‹k/ H3ÄH‰D$X3íE‹øL‹âL‹ñ¾   E…À„   H‹úI‹I‹ÎH‹@ÿï”  f;‡€   I‹I‹ÎH‹@ÿÖ”  ·ØI‹ÎI‹H‹@ÿÃ”  ·È·Ë;ÁwQ€ t;I‹HT$0H‰T$ LD$8A‹¬A¹   I‹ÎÆD$0 H‹@8ÿƒ”  …Àx	ŠG„D$0tîHƒÇA;ïségÿÿÿ3ö‹ÆH‹L$XH3ÌèZ  L\$`I‹[@I‹kHI‹ãA_A^A\_^ÃÌÌÌÌÌÌÌÌÌÌÌÌ·AXÃÌÌÌÌÌÌÌÌÌÌÌH‹A8E3ÀH…Àtf9Pw'·HD·H
ëA‹ÈE‹È·Á·Ê+ÈA·Á;È}A¸   A‹ÀÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌH‹ÄH‰XH‰hH‰pH‰x ATAVAWHƒì IƒÌÿH‹úI‹ÄE3ÿL‹ñ¾   HÿÀfD9<BuöH…ÀtXA‹ïI‹ÄHÿÀfD9<BuöH…ÀtAI‹ßI‹I‹Î·_H‹@Xÿc“  …Àu¸'   f;_uîI‹Ä‹İHÿÀfD9<GuöH;ØsëÅA‹÷‹ÆH‹\$@H‹l$HH‹t$PH‹|$XHƒÄ A_A^A\ÃÌÌÌÌÌÌÌÌH‰\$WHƒì ƒa H‰  Hƒa H‹ÙH‹y H‰ÇA   H…ÿt%Hÿ  D  L‹Ç3ÒH‹ÈHÿ]  D  Hƒc  H‹\$0HƒÄ _ÃÌÌÌÌÌÌÌÌH‰\$D‰L$ UVWATAUAVAWH‹ìHƒìp)t$`A‹ğL‹úL‹éE…À„¶  H…Ò„­  óup/58í  ‚›  ó2í  /Æ‚Š  è<ÒÿÿLEX3ÒI‹ÏèVñÿÿ‹Ø…Àˆr  A¸   A;Àu
»ÿÿ €é]  ·UXE3ö·ú…ötcA‹ÆE3äÁàIÇH‰E`LEPA‹ÔH‹Èè
ñÿÿ‹Ø…Àˆ&  A¸   A;Àt#·MP·EXf;ÏfGùf;ÈfBÁEàf‰EXH‹E`ë¹EğD;ör¡·UXf+ú(ŞfDÇI‹ÍèxÏÿÿ‹Ø…ÀˆĞ   3ÿÁæHEPD‹æH‰D$PIuH‹Mç‰|$HM‹ÄH‰|$@I‹×‰|$8ÇEP   ‰|$0è¼	  ‹Ø…Àˆˆ   D‹uPAFÿH@H<…(   ‹ÇH;øuhH‹D‹ÏI‹E3ÉH‰t$ D‹Bÿ‘  ‹Ø…ÀxLH‹LEPL‰D$PAV‰T$HM‹ÄI‹×ÇEP   ‰xH‹HAH‰D$@ƒd$8 ƒd$0 è7	  ‹Ø…Àxë»W €I‹ÍèªĞÿÿ‹ÃH‹œ$°   (t$`HƒÄpA_A^A]A\_^]ÃÌÌÌÌÌÌÌH‹ÄL‰H D‰@H‰PH‰HUSVWATAUAVAWHh¨Hì  HÇEşÿÿÿM‹éA‹øE3ÿA‹ß‰\$,Dˆ|$ LÆ…  L‰D$`HÇD$h   L‰|$pD‰|$xL‰}€L‰D$8HÇD$@   L‰|$HD‰|$PL‰|$XL‰EˆHÇE   L‰}˜D‰} L‰}¨L‰EàHÇEè   L‰}ğD‰}øL‰} L‰E¸HÇEÀ   E‹çL‰}ÈD‰}ĞL‰}ØH…Òu…ÿt
»W €é(  M…ÉtñL9ytë3ÒI‹Éèº  º   HL$`è³ØÿÿD‹t$lH‹u€…ÀxAFÿ¯D$hD‰<0D‰|$4E3Û…ÿ„Y  Gÿ‰D$(3ÒHL$8èvØÿÿE3ÛA‹Ë‰L$0‹|$DE…ö„¢  ‹D$h¯Á‹40¸*   L‹EhfA; …  D;|$(u/AT$HM¸è-ØÿÿE3ÛD‹eÄ…ÀˆJ  AL$ÿ¯MÀH‹EØé$  WHL$8èÿ×ÿÿ‹|$DE3Û…ÀxOÿ¯L$@H‹D$X‰4D8\$ …  ÆD$ 3ÒHMˆèÉ×ÿÿ‹U”ÿÂHMˆè»×ÿÿD‹u”…ÀxAFÿ¯EH‹U¨‰43ÒHMàè™×ÿÿE3Û‹uìE…ö„Ú   E‹ëH‹]¨D‹eL‹E`A‹ÄA¯Å‹I‹PHID‹|‚ Aº÷HI·D‚$AÇD;øƒ‚   KHÁáH‰M°D‹ğI‹@fD9\&tSWHL$8è"×ÿÿ‹|$D…ÀxOÿ¯L$@H‹D$XD‰<VHMàèıÖÿÿE3Û‹uìL‹E`…ÀxNÿ¯MèH‹E D‰<H‹M°AÿÇHƒÁH‰M°E;şr‘D‹u”AÿÅE;î‚Aÿÿÿ‹\$,L‹mxD‹eÄ…ö„Å   3ÒHMˆèÖÿÿ3ÀD‹ø…ötLD‹u”    * calling the `sizeCalculation` function and just use the specified
     * number if it is a positive integer, and `noDisposeOnSet` which
     * will prevent calling a `dispose` function in the case of
     * overwrites.
     *
     * If the `size` (or return value of `sizeCalculation`) for a given
     * entry is greater than `maxEntrySize`, then the item will not be
     * added to the cache.
     *
     * Will update the recency of the entry.
     *
     * If the value is `undefined`, then this is an alias for
     * `cache.delete(key)`. `undefined` is never stored in the cache.
     */
    set(k: K, v: V | BackgroundFetch<V> | undefined, setOptions?: LRUCache.SetOptions<K, V, FC>): this;
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */
    pop(): V | undefined;
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Check if a key is in the cache, without updating the recency of
     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
     * to `true` in either the options or the constructor.
     *
     * Will return `false` if the item is stale, even though it is technically in
     * the cache. The difference can be determined (if it matters) by using a
     * `status` argument, and inspecting the `has` field.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */
    has(k: K, hasOptions?: LRUCache.HasOptions<K, V, FC>): boolean;
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */
    peek(k: K, peekOptions?: LRUCache.PeekOptions<K, V, FC>): V | undefined;
    /**
     * Make an asynchronous cached fetch using the
     * {@link LRUCache.OptionsBase.fetchMethod} function.
     *
     * If the value is in the cache and not stale, then the returned
     * Promise resolves to the value.
     *
     * If not in the cache, or beyond its TTL staleness, then
     * `fetchMethod(key, staleValue, { options, signal, context })` is
     * called, and the value returned will be added to the cache once
     * resolved.
     *
     * If called with `allowStale`, and an asynchronous fetch is
     * currently in progress to reload a stale value, then the former
     * stale value will be returned.
     *
     * If called with `forceRefresh`, then the cached item will be
     * re-fetched, even if it is not stale. However, if `allowStale` is also
     * set, then the old value will still be returned. This is useful
     * in cases where you want to force a reload of a cached value. If
     * a background fetch is already in progress, then `forceRefresh`
     * has no effect.
     *
     * If multiple fetches for the same key are issued, then they will all be
     * coalesced into a single call to fetchMethod.
     *
     * Note that this means that handling options such as
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort},
     * {@link LRUCache.FetchOptions.signal},
     * and {@link LRUCache.OptionsBase.allowStaleOnFetchRejection} will be
     * determined by the FIRST fetch() call for a given key.
     *
     * This is a known (fixable) shortcoming which will be addresed on when
     * someone complains about it, as the fix would involve added complexity and
     * may not be worth the costs for this edge case.
     *
     * If {@link LRUCache.OptionsBase.fetchMethod} is not specified, then this is
     * effectively an alias for `Promise.resolve(cache.get(key))`.
     *
     * When the fetch method resolves to a value, if the fetch has not
     * been aborted due to deletion, eviction, or being overwritten,
     * then it is added to the cache using the options provided.
     *
     * If the key is evicted or deleted before the `fetchMethod`
     * resolves,       x¿¹O          Å¹O   &       ˜¿¹O   (       @À¹O   n       (Å¹O   o       @Å¹O   *       XÅ¹O          pÅ¹O          0Â¹O          ğ¿¹O          ˜Å¹O          È¿¹O          ¨Å¹O   s       ¸Å¹O   t       ÈÅ¹O   u       ØÅ¹O   v       èÅ¹O   w        Æ¹O   
       Æ¹O   y       (Æ¹O   '       XÀ¹O   x       0Æ¹O   z       HÆ¹O   {       XÆ¹O          À¹O   |       pÆ¹O          ˆÆ¹O          ˆ¿¹O           À¹O          ¨Æ¹O          ¸Æ¹O   €       ÈÆ¹O   }       ØÆ¹O   ~       èÆ¹O          pÀ¹O          øÆ¹O   i       ÀÀ¹O   p       Ç¹O           Ç¹O   ‚       8Ç¹O   Œ       PÇ¹O   …       hÇ¹O          `¿¹O   †       xÇ¹O   ‡       ˆÇ¹O           Ç¹O   $       ¸Ç¹O          ˆÀ¹O   "       ØÇ¹O          ğÇ¹O   ‰       È¹O   ‹       È¹O   Š       (È¹O          8È¹O          ØÀ¹O          XÈ¹O   r       hÈ¹O   „       ˆÈ¹O   ˆ       ˜È¹O                   ğTºO   UºO   ƒ¹O   p¸O    €¹O    €¹O   °¸O    ¸O   Ğ¸O   p¸O   @¸O   P¸O   °¸O    ¸O   Ğ¸O   p¸O   °¸O   À¸O   °¸O    ¸O   Ğ¸O    €¹O    €¹O    €¹O    %¸O    %¸O    %¸O    %¸O    %¸O   ¸O   °˜¸O   Ğš¸O   ğ›¸O   àœ¸O   Ğ ¸O    %¸O    %¸O    %¸O   Ğ¸O   €Î¸O   ğÎ¸O    Ï¸O   0Ï¸O   °Ğ¸O   `¸O   0Ğ¸O    %¸O   `¸O    %¸O   ÀĞ¸O   p¸O   p¸O   P¸O   `¸O   À¸O    ¸O   Ğ¸O    1¸O   ğ1¸O   p1¸O   3¸O   À(¸O   °¸O   Ğ¸O   ğ¸O     ¸O   ,¸O   °/¸O   `0¸O   Ğ/¸O   `&¸O   Ğ&¸O   p2¸O   3¸O   2¸O   0Ï¸O   °Ğ¸O   `¸O   0Ğ¸O    %¸O   `¸O    %¸O   ÀĞ¸O   Ğ3¸O    0¸O   à0¸O   À0¸O   0Ï¸O   °Ğ¸O   `¸O   0Ğ¸O    %¸O   `¸O    %¸O   ÀĞ¸O   p¸O    €¹O    €¹O    €¹O   `&¸O   Ğ&¸O   Ê¸O   àÉ¸O   4¸O    %¸O   `Å¸O   àÅ¸O   È¸O   È¸O   P&¸O   ÀÈ¸O    €¹O    €¹O   4¸O    %¸O    Å¸O   àÅ¸O    €¹O    €¹O    €¹O    €¹O   ĞB¸O   B¸O   Ğù¸O   Pß¸O   Ğá¸O   àá¸O   €æ¸O   pâ¸O    â¸O   @H¹O   PK¹O    J¹O   ĞJ¹O   K¹O    P¹O   U¹O   `¸O    ×¸O   `¸O   `¸O   pæ¸O   €Ø¸O   ÀI¹O   PL¹O    Q¹O   `¸O   àD¹O   °A¹O    ò¸O    ×¸O   €ò¸O   0ñ¸O   Ğæ¸O   ç¸O   Ğè¸O   @ä¸O   `è¸O   @õ¸O    ö¸O    ÷¸O   PÙ¸O    Ù¸O   é¸O   pü¸O   P¹O    ¹O    ¹O   °¹O    ¹O   ğ¹O   €¹O   @¹O   à¹O   °¹O   0¹O   ğ¹O   à¹O    ¹O    ¹O   À¹O   ¹O   `¹O   1¹O    ¹O    ¹O    ×¸O   0%¹O   À¹O   0¹O    ¹O   à¹O   °¹O   €¹O   @#¹O   @%¹O    $¹O    ¹O   ¹O   ğ#¹O    !¹O   %¹O   8¹O    €¹O    €¹O    €¹O    €¹O    €¹O    €¹O   @H¹O   PK¹O    J¹O   ĞJ¹O   K¹O    P¹O   U¹O    €¹O    €¹O    €¹O    €¹O    €¹O   A¹O   ÀI¹O   PL¹O    Q¹O    €¹O   àD¹O   °A¹O    %¸O    %¸O   `¸O    €¹O    €¹O    €¹O    €¹O    €¹O            >¹O   >¹O   @>¹O   €>¹O   Ğ>¹O   0?¹O    ?¹O    @¹O   `@¹O   °@¹O   ğW¹O    f¹O   °e¹O   f¹O   `h¹O   °j¹O    l¹O   Pm¹O   @b¹O   pb¹O   €g¹O   3¸O   àa¹O    b¹O   0b¹O   Ğd¹O   ğe¹O    f¹O   Ğe¹O   €c¹O   ğo¹O    r¹O   Àe¹O   àe¹O    e¹O   Pe¹O   Ğb¹O   ğb¹O   c¹O   Pc¹O   pe¹O   `c¹O   pn¹O   `¸O   `¸O   `¸O   `¸O   `¸O   `¸O   pc¹O   €g¹O   3¸O   àa¹O    b¹O   0b¹O   °f¹O   Àe¹O   àe¹O    e¹O   0f¹O   Ğb¹O   ğb¹O   c¹O   Pc¹O   Pf¹O   `c¹O   pn¹O   `¸O   `¸O   `¸O   `¸O   `¸O   `¸O   pc¹O   ĞÊ¹O                                          °É¹O                                                                                                                                        ¨SºO                   X¹¹O   `¹¹O   8º¹O          u            @¿¹O                                                                                                                  \ºO   dºO   pZºO   0º¹O         0 fE     øE      A     |E     ’E     ÊE     äE     A     €A     nA     F             jH     \H     HH     :H     (H     H     şG     òG     ÚG     ÂG     vH     G     G     ~G     fG     LG     4G     G     G     ¬G     ¼A     ÎA     æA     üA     B     &B     BB     RB     dB     vB     B     ¢B     ªB     ¾B     ØB     ìB     C     &C     :C     NC     hC     ~C     ”C     ®C     „H     F     0F     FF     RF     bF     vF     ŒF     ªF     ÌF     âF     òF                   €      €      €      €¡      €£      €        ºH     ¢H             æC     ÚC             ®D     ÂD             DD     2D     D     ZD             D             \E     òD     RE     E     HE     @E     (E     2E      E     p?     èH     VA     LA     >A     4A     ,A     A      A     ò@     ä@     Ú@     Ğ@     º@     œ@     „@     f@     F@     &@     @     @     ø?     ì?     à?     Ø?     Ì?     ´?     ¨?     –?     €?     E     ŞH     òH             Àƒ¹O   @‡¹O           0¸O   p¸O   °¸O   ¸O   0¸O   P¸O   p¸O   ¸O   ğ¸O    ¸O   €¸O    ¸O   À¸O    ¸O   ¸O   °¸O    ¸O    ¸O   @¸O                   Ğy¹O                              0   P   p      0   p   °   ğ       €       À          °           @   p   °   Ğ       @   P   °   À   P   `   À      `   p   Ğ   °   Ğ   ğ         %   P&   `&   