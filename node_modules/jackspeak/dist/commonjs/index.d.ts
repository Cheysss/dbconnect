/// <reference types="node" />
export type ConfigType = 'number' | 'string' | 'boolean';
/**
 * Given a Jack object, get the typeof its ConfigSet
 */
export type Unwrap<J> = J extends Jack<infer C> ? C : never;
import { inspect, InspectOptions } from 'node:util';
/**
 * Defines the type of value that is valid, given a config definition's
 * {@link ConfigType} and boolean multiple setting
 */
export type ValidValue<T extends ConfigType = ConfigType, M extends boolean = boolean> = [
    T,
    M
] extends ['number', true] ? number[] : [T, M] extends ['string', true] ? string[] : [T, M] extends ['boolean', true] ? boolean[] : [T, M] extends ['number', false] ? number : [T, M] extends ['string', false] ? string : [T, M] extends ['boolean', false] ? boolean : [T, M] extends ['string', boolean] ? string | string[] : [T, M] extends ['boolean', boolean] ? boolean | boolean[] : [T, M] extends ['number', boolean] ? number | number[] : [T, M] extends [ConfigType, false] ? string | number | boolean : [T, M] extends [ConfigType, true] ? string[] | number[] | boolean[] : string | number | boolean | string[] | number[] | boolean[];
/**
 * The meta information for a config option definition, when the
 * type and multiple values can be inferred by the method being used
 */
export type ConfigOptionMeta<T extends ConfigType, M extends boolean = boolean, O extends undefined | (T extends 'boolean' ? never : T extends 'string' ? readonly string[] : T extends 'number' ? readonly number[] : readonly number[] | readonly string[]) = undefined | (T extends 'boolean' ? never : T extends 'string' ? readonly string[] : T extends 'number' ? readonly number[] : readonly number[] | readonly string[])> = {
    default?: undefined | (ValidValue<T, M> & (O extends number[] | string[] ? M extends false ? O[number] : O[number][] : unknown));
    validOptions?: O;
    description?: string;
    validate?: ((v: unknown) => v is ValidValue<T, M>) | ((v: unknown) => boolean);
    short?: string | undefined;
    type?: T;
    hint?: T extends 'boolean' ? never : string;
    delim?: M extends true ? string : never;
} & (M extends false ? {
    multiple?: false | undefined;
} : M extends true ? {
    multiple: true;
} : {
    multiple?: boolean;
});
/**
 * A set of {@link ConfigOptionMeta} fields, referenced by their longOption
 * string values.
 */
export type ConfigMetaSet<T extends ConfigType, M extends boolean = boolean> = {
    [longOption: string]: ConfigOptionMeta<T, M>;
};
/**
 * Infer {@link ConfigSet} fields from a given {@link ConfigMetaSet}
 */
export type ConfigSetFromMetaSet<T extends ConfigType, M extends boolean, S extends ConfigMetaSet<T, M>> = {
    [longOption in keyof S]: ConfigOptionBase<T, M>;
};
/**
 * Fields that can be set on a {@link ConfigOptionBase} or
 * {@link ConfigOptionMeta} based on whether or not the field is known to be
 * multiple.
 */
export type MultiType<M extends boolean> = M extends true ? {
    multiple: true;
    delim?: string | undefined;
} : M extends false ? {
    multiple?: false | undefined;
    delim?: undefined;
} : {
    multiple?: boolean | undefined;
    delim?: string | undefined;
};
/**
 * A config field definition, in its full representation.
 */
export type ConfigOptionBase<T extends ConfigType, M extends boolean = boolean> = {
    type: T;
    short?: string | undefined;
    default?: ValidValue<T, M> | undefined;
    description?: string;
    hint?: T extends 'boolean' ? undefined : string | undefined;
    validate?: (v: unknown) => v is ValidValue<T, M>;
    validOptions?: T extends 'boolean' ? undefined : T extends 'string' ? readonly string[] : T extends 'number' ? readonly number[] : readonly number[] | readonly string[];
} & MultiType<M>;
export declare const isConfigType: (t: string) => t is ConfigType;
export declare const isConfigOption: <T extends ConfigType, M extends boolean>(o: any, type: T, multi: M) => o is ConfigOptionBase<T, M>;
/**
 * A set of {@link ConfigOptionBase} objects, referenced by their longOption
 * string values.
 */
export type ConfigSet = {
    [longOption: string]: ConfigOptionBase<ConfigType>;
};
/**
 * The 'values' field returned by {@link Jack#parse}
 */
export type OptionsResults<T extends ConfigSet> = {
    [k in keyof T]?: T[k]['validOptions'] extends (readonly string[] | readonly number[]) ? T[k] extends ConfigOptionBase<'string' | 'number', false> ? T[k]['validOptions'][number] : T[k] extends ConfigOptionBase<'string' | 'number', true> ? T[k]['validOptions'][number][] : never : T[k] extends ConfigOptionBase<'string', false> ? string : T[k] extends ConfigOptionBase<'string', true> ? string[] : T[k] extends ConfigOptionBase<'number', false> ? number : T[k] extends ConfigOptionBase<'number', true> ? number[] : T[k] extends ConfigOptionBase<'boolean', false> ? boolean : T[k] extends ConfigOptionBase<'boolean', true> ? boolean[] : never;
};
/**
 * The object retured by {@link Jack#parse}
 */
export type Parsed<T extends ConfigSet> = {
    values: OptionsResults<T>;
    positionals: string[];
};
/**
 * A row used when generating the {@link Jack#usage} string
 */
export interface Row {
    left?: string;
    text: string;
    skipLine?: boolean;
    type?: string;
}
/**
 * A heading for a section in the usage, created by the jack.heading()
 * method.
 *
 * First heading is always level 1, subsequent headings default to 2.
 *
 * The level of the nearest heading level sets the indentation of the
 * description that follows.
 */
export interface Heading extends Row {
    type: 'heading';
    text: string;
    left?: '';
    skipLine?: boolean;
    level: number;
    pre?: boolean;
}
/**
 * An arbitrary blob of text describing some stuff, set by the
 * jack.description() method.
 *
 * Indentation determined by level of the nearest header.
 */
export interface Description extends Row {
    type: 'description';
    text: string;
    left?: '';
    skipLine?: boolean;
    pre?: boolean;
}
/**
 * A heading or description row used when generating the {@link Jack#usage}
 * string
 */
export type TextRow = Heading | Description;
/**
 * Either a {@link TextRow} or a reference to a {@link ConfigOptionBase}
 */
export type UsageField = TextRow | {
    type: 'config';
    name: string;
    value: ConfigOptionBase<ConfigType>;
};
/**
 * Options provided to the {@link Jack} constructor
 */
export interface JackOptions {
    /**
     * Whether to allow positional arguments
     *
     * @default true
     */
    allowPositionals?: boolean;
    /**
     * Prefix to use when reading/writing the environment variables
     *
     * If not specified, environment behavior will not be available.
     */
    envPrefix?: string;
    /**
     * Environment object to read/write. Defaults `process.env`.
     * No effect if `envPrefix` is not set.
     */
    env?: {
        [k: string]: string | undefined;
    };
    /**
     * A short usage string. If not provided, will be generated from the
     * options provided, but that can of course be rather verbose if
     * there are a lot of options.
     */
    usage?: string;
    /**
     * Stop parsing flags and opts at the first positional argument.
     * This is to support cases like `cmd [flags] <subcmd> [options]`, where
     * each subcommand may have different options.  This effectively treats
     * any positional as a `--` argument.  Only relevant if `allowPositionals`
     * is true.
     *
     * To do subcommands, set this option, look at the first positional, and
     * parse the remaining positionals as appropriate.
     *
     * @default false
     */
    stopAtPositional?: boolean;
    /**
     * Conditional `stopAtPositional`. If set to a `(string)=>boolean` function,
     * will be called with each positional argument encountered. If the function
     * returns true, then parsing will stop at that point.
     */
    stopAtPositionalTest?: (arg: string) => boolean;
}
/**
 * Class returned by the {@link jack} function and all configuration
 * definition methods.  This is what gets chained together.
 */
export declare class Jack<C extends ConfigSet = {}> {
    #private;
    constructor(options?: JackOptions);
    /**
     * Set the default value (which will è  ¤ğŞ¿   `†  @ `¼ » ³^† » Sh  ¡ C`¼ €7ôfDà  • `¼ ‚ğ^  »ğfDl  · Wh  ğŞ¿ » ×A‡ { c`¼ z `¼ u`¬ ¿ ×A‡ ¾ ßA I0	à€ Ù SŞ  ”—òà€ ğ^  È‘ §€h  xà‚ Ç ãÁ @ `¼ ËğŞ¿ Ğ Ã€  ¡W	dDà  ¡7!†^è  îğ^  Î1ôfÄl  ÙğŞ¿ £'!*è  Ø `¼ Q °  R `¼ P1 `¼ Õ CE€ nğŞ¿ @ `¼ 	 +°  Ú ï©h  	 /°  \Ïa¼ ] `¼ ^ğÏa¼ _ğ
;`¼ /ğ^  8ğ^  $ğ^  æ ³^ ¡—/à  À+ôfDá  Á kÄà   Ë±  —`¼ €7`¼ ğ^  €7`¼ ğ^  ¡w gDà  í1ôfÄl  ÷b¼ €×`¼ ğ^  €`¼ ğ^  ¡w gDà  ô1ôfÄl  —`¼ €÷`¼ ğ^  €7`¼ ğ^  ¡w gDà  û1ôfÄl  `¼ €W`¼ ğ^  €W`¼ ğ^  ¡w gDà  2ôfÄl  —`¼ €÷`¼ ğ^  €7`¼ ğ^  ¡7 gDà  	2ôfÄl  ÷`¼ €÷`¼ ğ^  €7`¼ ğ^  ¡W gDà  2ôfÄl  ÷`¼ €÷`¼ ğ^  €7`¼ ğ^  ¡W gDà  2ôfÄl  `¼ €W`¼ ğ^  €W`¼ ğ^  - Ë1 - C„ £ `¼ ¡W`¼ ¢ Sb¼ [ğ^  e/`¼ ¡—`¼ ¢ Z°  [ğ^  ¡w`¼ ¢ Z°  [ğ^  eP —Aà  £7 ^à  $Şh  ” `¼ ¹ §€m  ¡wgDà  02#†Şh  ¹ğŞ¿ †Ğ^ˆ ¡ ^ †Ğ†^‚ †Ğò^­ 8 Ã€ƒ †Ğ^ ¡w _‰ > +Â‘ ¢ B =Rôà(  ¢ ¯°  ¡7ôŠ^ˆ †Ğ†^› Z ³1h  N Bˆ ¡W`¼ ¢·
ó`¼ [ğ^  ¡w`¼ ¢ ¿1°  [ğ^  ¡W`¼ ¢×
ó`¼ [ğ^  ¡w`¼ ¢ Ã1°  [ğ^  ZğŞ¿ ¡W`¼ ¢·
ó`¼ [ğ^  ¡w`¼ ¢ ·1°  [ğ^  ¡W`¼ ¢×
ó`¼ [ğ^  ¡w`¼ ¢ »1°  [ğ^    ğŞ  ¡ T°  b Ş  e ‹A°  ¡×`¼ Üğ^  ¡÷ „^à  gğŞ¿ g ó€ g ^ g ^€ ¢7    ¡WôTè    ğŞ  k ¿  Iğ^  lğŞ¿ E±ğ¶D     ğŞ  } ¿   } «h  ¨7 £^à  }Ò ^m  ¡ -°  Uğ^  ¢ g@°  zòÿ£Şh  ¢wh‰^°  y’ § m  {R ¯Ÿm  zğŞ¿ { ¯Ÿh  ¢wh‰^¸  [ğ^  ¨ `¼   ğŞ  ¢ZØ  ¢WôZ¸   V°   V°   V°   V°   V°  HôVà  ş Z°  ÿ ‹^8 ¤  °  ¢ `¼ e “A°  ¤Ğ’^¸  cPô^à  £ “^ğ  ¤w “^ğ  ¢7 ‹^à  ¤wô’^¸  ePô’Aà  €•ôVà  ¤ V°  ‹² ‹Şn  ¢×À’^¸  ¢7 ‹^Ø   Hô à  ¤  °  ¢÷À’^¸  ¢7 ‹^Ø  Hô à  ¢7  Ø  Hô
 à  ¢7  Ø  Hô à  ¢7  Ø  Hô à  ¢7  Ø  Hô à  ¢  °  ¢ÀŠ^¸  ¢7 ‹^  ÿçÿˆ^¼   ğŞ  ä‘<`€ æÑ<`‡ æÑ<`¨ æÑ<`‹ c ^°  ç V°  ç V°  ç V°  ç V°  ä‘<B`© æÑ<`¨ æÑ<`‹ c ‹^°  ¡W `¼ ¹ V ¡`¼ c0ôAà  ç V°  ç V°  ç V°  c ‹^°  ¡· `¼ Ã Ö ¡`¼ Ã S^ ¡—`¼ c0ôAà  ç V°  ç V°  ç V°  ¡ `¼ Î SŞ c ‹^°  Í S^ ¡÷?V   ÎğŞ¿ ¡÷3V   ç ‡^°  ç `¼   ğŞ  ëÒ ›^h  ã`¼ ŞR ›Şh  á‡Gè  â `¼ â `¼ â `¼ â `¼ â `¼ â `¼ â `¼ â `¼ àQôBa°  â X°  â X°  â X°  â X°  â X°  â X°  â X°  â X°  ¤ ›^°  é² ›Şh  ¤w `¼ £“Ş’   ğŞ  ã `¼ â X°  â X°  â X°  â X°  â X°  â X°  â X°  â X°  dğFà  ã1 `¼ â X°  â X°  â X°  â X°  â X°  â X°  â X°  â X°  £ à’   ğŞ    Ã@‡ 0ğ`†  Ã@†  Ç@°    ğŞ   Ã@‡ 1 ^°  0ğà†   ğŞ  Ü™ § h  7ğŞ¿ ¡`¼ Uğ^  ¸ g@°  ¢7` [ğ^  I0	` IĞ`¼ ¡W gDà  3ôfÄh  ğ^  8ğ^  I'A¨  I0	` ¡`¼ ¢ ã°  [ğ^    ğŞ  ñ™ § h  Ó™ § h  Óğ^    ğŞ  I0	` #“ § h  @ğ^    ğŞ  ¡7`¼ Uğ^  £ g@°  ¢7^°  [ğ^  @ğ^  ¡7`¼ ¢ ^°  [ğ^  I0	`   ğŞ  I0	àˆ   'A°   + °    ğŞ   `¼ xà‚ I `¼   'A°    ğŞ  5š § h  ¡·`¼ Uğ^  ¢7şé > SŞ€ ¢7`é [ğ^    ğŞ  ¦ SŞ  >š § h  ¡7 `¼ DğŞ¿ Uğ^  ¢7`‡ H ›Şh  ¢7`‡ [ğ^    ğŞ  Ì A   gD°  O S^‚ ”—ò`‚ å kD°  ¤·ühDè  RS “Şm  Ì	şà   Ì #E„ Ì #E¬ Ì ³^… ¡7`¼ Uğ^  Y g@  ÌğŞ¿ I0	` ¡—`¼ Uğ^  † g@°  ¡·`¼ Uğ^  ‡ g@°  ¢ /°  [ğ^  ¡·`¼ [ğ^  ¡×`¼ Uğ^  { g@°  ¡÷`¼ Uğ^  … g@°  ¢ /°  [ğ^  ¡÷`¼ [ğ^  ¡W`¼ ¢ /°  [ğ^  ¡w`¼ ¢ /°  [ğ^  ˆ ç°  ‰ ï°  Š¡`¼ I `¼ ‰ Ç€ ¢ #.°  ¡ Ï°  [ğ^  ¡ Ó°  [ğ^  ¡ ×°  [ğ^  ¢ '.°  ¡ Û°  [ğ^  ¡ ß°  [ğ^  ¡ ã°  [ğ^  ¢ ÷°  àğ^  S£ m  ¡7`¼ Uğ^  £ g@°  ¢÷`¼ [ğ^  ¡7`¼ ¢7 `¼ [ğ^  Uğ^  ’ g@€ ˜S£ m  ¡7`¼ ¢ ^°  [ğ^  › Ç€ ¢ `¼ àğ^  e`¼ „ `¼ … `¼ † `¼ ‡ `¼ ¢×`¼ £ `¼ ¡wôŠ^à  Uğ^  €6Úá  £7 ^à  e0 —A¸  ¢“ Şh  eP —Aà  ¢×`¼ ¡Ó0—Ah  µ Ç€ µ³+h  ¡ °  °ó0„Şm  ¡ °  µ‡^m  ˆ ë°  ‰ ó°  Š¡`¼ xğŞ¿ ¹3 “^n  £×xeDà  ½ 'Åh  ·3#Şh  F  C°  G`¼ C `¼ ”—ò`‚ ¢ 