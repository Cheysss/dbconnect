/// <reference types="node" />
export type ConfigType = 'number' | 'string' | 'boolean';
/**
 * Given a Jack object, get the typeof its ConfigSet
 */
export type Unwrap<J> = J extends Jack<infer C> ? C : never;
import { inspect, InspectOptions } from 'node:util';
/**
 * Defines the type of value that is valid, given a config definition's
 * {@link ConfigType} and boolean multiple setting
 */
export type ValidValue<T extends ConfigType = ConfigType, M extends boolean = boolean> = [
    T,
    M
] extends ['number', true] ? number[] : [T, M] extends ['string', true] ? string[] : [T, M] extends ['boolean', true] ? boolean[] : [T, M] extends ['number', false] ? number : [T, M] extends ['string', false] ? string : [T, M] extends ['boolean', false] ? boolean : [T, M] extends ['string', boolean] ? string | string[] : [T, M] extends ['boolean', boolean] ? boolean | boolean[] : [T, M] extends ['number', boolean] ? number | number[] : [T, M] extends [ConfigType, false] ? string | number | boolean : [T, M] extends [ConfigType, true] ? string[] | number[] | boolean[] : string | number | boolean | string[] | number[] | boolean[];
/**
 * The meta information for a config option definition, when the
 * type and multiple values can be inferred by the method being used
 */
export type ConfigOptionMeta<T extends ConfigType, M extends boolean = boolean, O extends undefined | (T extends 'boolean' ? never : T extends 'string' ? readonly string[] : T extends 'number' ? readonly number[] : readonly number[] | readonly string[]) = undefined | (T extends 'boolean' ? never : T extends 'string' ? readonly string[] : T extends 'number' ? readonly number[] : readonly number[] | readonly string[])> = {
    default?: undefined | (ValidValue<T, M> & (O extends number[] | string[] ? M extends false ? O[number] : O[number][] : unknown));
    validOptions?: O;
    description?: string;
    validate?: ((v: unknown) => v is ValidValue<T, M>) | ((v: unknown) => boolean);
    short?: string | undefined;
    type?: T;
    hint?: T extends 'boolean' ? never : string;
    delim?: M extends true ? string : never;
} & (M extends false ? {
    multiple?: false | undefined;
} : M extends true ? {
    multiple: true;
} : {
    multiple?: boolean;
});
/**
 * A set of {@link ConfigOptionMeta} fields, referenced by their longOption
 * string values.
 */
export type ConfigMetaSet<T extends ConfigType, M extends boolean = boolean> = {
    [longOption: string]: ConfigOptionMeta<T, M>;
};
/**
 * Infer {@link ConfigSet} fields from a given {@link ConfigMetaSet}
 */
export type ConfigSetFromMetaSet<T extends ConfigType, M extends boolean, S extends ConfigMetaSet<T, M>> = {
    [longOption in keyof S]: ConfigOptionBase<T, M>;
};
/**
 * Fields that can be set on a {@link ConfigOptionBase} or
 * {@link ConfigOptionMeta} based on whether or not the field is known to be
 * multiple.
 */
export type MultiType<M extends boolean> = M extends true ? {
    multiple: true;
    delim?: string | undefined;
} : M extends false ? {
    multiple?: false | undefined;
    delim?: undefined;
} : {
    multiple?: boolean | undefined;
    delim?: string | undefined;
};
/**
 * A config field definition, in its full representation.
 */
export type ConfigOptionBase<T extends ConfigType, M extends boolean = boolean> = {
    type: T;
    short?: string | undefined;
    default?: ValidValue<T, M> | undefined;
    description?: string;
    hint?: T extends 'boolean' ? undefined : string | undefined;
    validate?: (v: unknown) => v is ValidValue<T, M>;
    validOptions?: T extends 'boolean' ? undefined : T extends 'string' ? readonly string[] : T extends 'number' ? readonly number[] : readonly number[] | readonly string[];
} & MultiType<M>;
export declare const isConfigType: (t: string) => t is ConfigType;
export declare const isConfigOption: <T extends ConfigType, M extends boolean>(o: any, type: T, multi: M) => o is ConfigOptionBase<T, M>;
/**
 * A set of {@link ConfigOptionBase} objects, referenced by their longOption
 * string values.
 */
export type ConfigSet = {
    [longOption: string]: ConfigOptionBase<ConfigType>;
};
/**
 * The 'values' field returned by {@link Jack#parse}
 */
export type OptionsResults<T extends ConfigSet> = {
    [k in keyof T]?: T[k]['validOptions'] extends (readonly string[] | readonly number[]) ? T[k] extends ConfigOptionBase<'string' | 'number', false> ? T[k]['validOptions'][number] : T[k] extends ConfigOptionBase<'string' | 'number', true> ? T[k]['validOptions'][number][] : never : T[k] extends ConfigOptionBase<'string', false> ? string : T[k] extends ConfigOptionBase<'string', true> ? string[] : T[k] extends ConfigOptionBase<'number', false> ? number : T[k] extends ConfigOptionBase<'number', true> ? number[] : T[k] extends ConfigOptionBase<'boolean', false> ? boolean : T[k] extends ConfigOptionBase<'boolean', true> ? boolean[] : never;
};
/**
 * The object retured by {@link Jack#parse}
 */
export type Parsed<T extends ConfigSet> = {
    values: OptionsResults<T>;
    positionals: string[];
};
/**
 * A row used when generating the {@link Jack#usage} string
 */
export interface Row {
    left?: string;
    text: string;
    skipLine?: boolean;
    type?: string;
}
/**
 * A heading for a section in the usage, created by the jack.heading()
 * method.
 *
 * First heading is always level 1, subsequent headings default to 2.
 *
 * The level of the nearest heading level sets the indentation of the
 * description that follows.
 */
export interface Heading extends Row {
    type: 'heading';
    text: string;
    left?: '';
    skipLine?: boolean;
    level: number;
    pre?: boolean;
}
/**
 * An arbitrary blob of text describing some stuff, set by the
 * jack.description() method.
 *
 * Indentation determined by level of the nearest header.
 */
export interface Description extends Row {
    type: 'description';
    text: string;
    left?: '';
    skipLine?: boolean;
    pre?: boolean;
}
/**
 * A heading or description row used when generating the {@link Jack#usage}
 * string
 */
export type TextRow = Heading | Description;
/**
 * Either a {@link TextRow} or a reference to a {@link ConfigOptionBase}
 */
export type UsageField = TextRow | {
    type: 'config';
    name: string;
    value: ConfigOptionBase<ConfigType>;
};
/**
 * Options provided to the {@link Jack} constructor
 */
export interface JackOptions {
    /**
     * Whether to allow positional arguments
     *
     * @default true
     */
    allowPositionals?: boolean;
    /**
     * Prefix to use when reading/writing the environment variables
     *
     * If not specified, environment behavior will not be available.
     */
    envPrefix?: string;
    /**
     * Environment object to read/write. Defaults `process.env`.
     * No effect if `envPrefix` is not set.
     */
    env?: {
        [k: string]: string | undefined;
    };
    /**
     * A short usage string. If not provided, will be generated from the
     * options provided, but that can of course be rather verbose if
     * there are a lot of options.
     */
    usage?: string;
    /**
     * Stop parsing flags and opts at the first positional argument.
     * This is to support cases like `cmd [flags] <subcmd> [options]`, where
     * each subcommand may have different options.  This effectively treats
     * any positional as a `--` argument.  Only relevant if `allowPositionals`
     * is true.
     *
     * To do subcommands, set this option, look at the first positional, and
     * parse the remaining positionals as appropriate.
     *
     * @default false
     */
    stopAtPositional?: boolean;
    /**
     * Conditional `stopAtPositional`. If set to a `(string)=>boolean` function,
     * will be called with each positional argument encountered. If the function
     * returns true, then parsing will stop at that point.
     */
    stopAtPositionalTest?: (arg: string) => boolean;
}
/**
 * Class returned by the {@link jack} function and all configuration
 * definition methods.  This is what gets chained together.
 */
export declare class Jack<C extends ConfigSet = {}> {
    #private;
    constructor(options?: JackOptions);
    /**
     * Set the default value (which will Ë  §ﬁø   `Ü  @ `º ª ≥^Ü ª Sh  ° C`º Ä7ÙfD‡  ï `º Ç^  ªfDl  ∑ Wh  ﬁø ª ◊Aá { c`º z `º uê`¨ ø ◊Aá æ ﬂA I0	‡Ä Ÿ Sﬁ  îóÚ‡Ä ^  »ë ßÄh  x‡Ç « „¡ @ `º Àﬁø – √Ä  °W	dD‡  °7!Ü^Ë  Ó^  Œ1Ùfƒl  Ÿﬁø £'!*Ë  ÿ `º Q è∞  R `º P1 `º ’ CEÄ nﬁø @ `º 	 +∞  ⁄ Ô©h  	 /∞  \œaº ] `º ^œaº _
;`º /^  8^  $^  Ê ≥^ °ó/‡  ¿+ÙfD·  ¡ kƒ‡   À±  Åó`º Ä7`º ^  Ä7`º ^  °w gD‡  Ì1Ùfƒl  Å˜bº Ä◊`º ^  Ä`º ^  °w gD‡  Ù1Ùfƒl  Åó`º Ä˜`º ^  Ä7`º ^  °w gD‡  ˚1Ùfƒl  Å`º ÄW`º ^  ÄW`º ^  °w gD‡  2Ùfƒl  Åó`º Ä˜`º ^  Ä7`º ^  °7 gD‡  	2Ùfƒl  Å˜`º Ä˜`º ^  Ä7`º ^  °W gD‡  2Ùfƒl  Å˜`º Ä˜`º ^  Ä7`º ^  °W gD‡  2Ùfƒl  Å`º ÄW`º ^  ÄW`º ^  - À1 - CÑ £ `º °W`º ¢ Sbº [^  eê/`º °ó`º ¢ Z∞  [^  °w`º ¢ Z∞  [^  eP óA‡  £7 è^‡  $èﬁh  î `º πç ßÄm  °wgD‡  02#Üﬁh  πﬁø Ü–^à ° ^ Ü–Ü^Ç Ü–Ú^≠ 8 √ÄÉ Ü–^ù °w _â > +¬ë ¢ B =RÙ‡(  ¢ Ø∞  °7Ùä^à Ü–Ü^õ Z ≥1h  N Bà °W`º ¢∑
Û`º [^  °w`º ¢ ø1∞  [^  °W`º ¢◊
Û`º [^  °w`º ¢ √1∞  [^  Zﬁø °W`º ¢∑
Û`º [^  °w`º ¢ ∑1∞  [^  °W`º ¢◊
Û`º [^  °w`º ¢ ª1∞  [^    ﬁ  ° T∞  b ﬁ  e ãA∞  °◊`º ‹^  °˜ Ñ^‡  gﬁø g ÛÄ g ^ g ^Ä ¢7  ê  °WÙTË    ﬁ  k ø  I^  lﬁø E±∂D†    ﬁ  } ø   } ´h  ®7 £^‡  }“†^m  ° -∞  U^  ¢ g@∞  zÚˇ£ﬁh  ¢whâ^∞  yí ß m  {R Øüm  zﬁø { Øüh  ¢whâ^∏  [^  ® `º   ﬁ  ¢Zÿ  ¢WÙZ∏   V∞   V∞   V∞   V∞   V∞  HÙV‡  ˛ Z∞  ˇ ã^8 §  ∞  ¢ `º e ìA∞  §–í^∏  cPÙ^‡  £ ì^  §w ì^  ¢7 ã^‡  §wÙí^∏  ePÙíA‡  ÄïÙV‡  § V∞  ã≤ ãﬁn  ¢◊¿í^∏  ¢7 ã^ÿ   HÙ ‡  §  ∞  ¢˜¿í^∏  ¢7 ã^ÿ  HÙ ‡  ¢7  ÿ  HÙ
 ‡  ¢7  ÿ  HÙ ‡  ¢7  ÿ  HÙ ‡  ¢7  ÿ  HÙ ‡  ¢  ∞  ¢¿ä^∏  ¢7 ã^ê  ˇÁˇà^º   ﬁ  ‰ë<`Ä Ê—<`á Ê—<`® Ê—<`ã c è^∞  Á V∞  Á V∞  Á V∞  Á V∞  ‰ë<B`© Ê—<`® Ê—<`ã c ã^∞  °W `º π V °`º c0ÙéA‡  Á V∞  Á V∞  Á V∞  c ã^∞  °∑ `º √ ÷ °`º √ S^ °ó`º c0ÙéA‡  Á V∞  Á V∞  Á V∞  ° `º Œ Sﬁ c ã^∞  Õ S^ °˜?V†  Œﬁø °˜3V†  Á á^∞  Á `º   ﬁ  Î“ õ^h  „`º ﬁR õﬁh  ·áGË  ‚ `º ‚ `º ‚ `º ‚ `º ‚ `º ‚ `º ‚ `º ‚ `º ‡QÙBa∞  ‚ X∞  ‚ X∞  ‚ X∞  ‚ X∞  ‚ X∞  ‚ X∞  ‚ X∞  ‚ X∞  § õ^∞  È≤ õﬁh  §w `º £ìﬁí   ﬁ  „ `º ‚ X∞  ‚ X∞  ‚ X∞  ‚ X∞  ‚ X∞  ‚ X∞  ‚ X∞  ‚ X∞  dF‡  „1 `º ‚ X∞  ‚ X∞  ‚ X∞  ‚ X∞  ‚ X∞  ‚ X∞  ‚ X∞  ‚ X∞  £ ‡í   ﬁ    √@á 0`Ü  √@Ü Å «@∞    ﬁ   √@á 1 ^∞  0‡Ü   ﬁ  ‹ô ß h  7ﬁø °`º U^  ∏ g@∞  ¢7`ê [^  I0	`Å I–`º °W gD‡  3Ùfƒh  ^  8^  I'A®  I0	`Å °`º ¢ „∞  [^    ﬁ  Òô ß h  ”ô ß h  ”^    ﬁ  I0	`Å #ì ß h  @^    ﬁ  °7`º U^  £ g@∞  ¢7è^∞  [^  @^  °7`º ¢ è^∞  [^  I0	`Å   ﬁ  I0	‡à   'A∞   + ∞    ﬁ   `º x‡Ç I `º   'A∞    ﬁ  5ö ß h  °∑`º U^  ¢7˛È > SﬁÄ ¢7`È [^    ﬁ  ¶ Sﬁ  >ö ß h  °7 `º Dﬁø U^  ¢7`á H õﬁh  ¢7`á [^    ﬁ  Ã A   gD∞  O S^Ç îóÚ`Ç Â kD∞  §∑¸hDË  RS ìﬁm  Ã	˛‡   Ã #EÑ Ã #E¨ Ã ≥^Ö °7`º U^  Y g@  Ãﬁø I0	`Å °ó`º U^  Ü g@∞  °∑`º U^  á g@∞  ¢ /∞  [^  °∑`º [^  °◊`º U^  { g@∞  °˜`º U^  Ö g@∞  ¢ /∞  [^  °˜`º [^  °W`º ¢ /∞  [^  °w`º ¢ /∞  [^  à Á∞  â Ô∞  ä°`º I `º â «Ä ¢ #.∞  ° œ∞  [^  ° ”∞  [^  ° ◊∞  [^  ¢ '.∞  ° €∞  [^  ° ﬂ∞  [^  ° „∞  [^  ¢ ˜∞  ‡^  èS£ m  °7`º U^  £ g@∞  ¢˜`º [^  °7`º ¢7 `º [^  U^  í g@Ä òS£ m  °7`º ¢ è^∞  [^  õ «Ä ¢ `º ‡^  eê`º Ñ `º Ö `º Ü `º á `º ¢◊`º £ `º °wÙä^‡  U^  Ä6⁄·  £7 è^‡  e0 óA∏  ¢ì èﬁh  eP óA‡  ¢◊`º °”0óAh  µ «Ä µ≥+h  ° ∞  ∞Û0Ñﬁm  ° ∞  µá^m  à Î∞  â Û∞  ä°`º xﬁø π3 ì^n  £◊xeD‡  Ω '≈h  ∑3#éﬁh  F  C∞  G`º Cê `º îóÚ`Ç ¢ 