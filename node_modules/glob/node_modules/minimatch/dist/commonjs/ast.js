"use strict";
// parse a single path portion
Object.defineProperty(exports, "__esModule", { value: true });
exports.AST = void 0;
const brace_expressions_js_1 = require("./brace-expressions.js");
const unescape_js_1 = require("./unescape.js");
const types = new Set(['!', '?', '+', '*', '@']);
const isExtglobType = (c) => types.has(c);
// Patterns that get prepended to bind to the start of either the
// entire string, or just a single path portion, to prevent dots
// and/or traversal patterns, when needed.
// Exts don't need the ^ or / bit, because the root binds that already.
const startNoTraversal = '(?!(?:^|/)\\.\\.?(?:$|/))';
const startNoDot = '(?!\\.)';
// characters that indicate a start of pattern needs the "no dots" bit,
// because a dot *might* be matched. ( is not in the list, because in
// the case of a child extglob, it will handle the prevention itself.
const addPatternStart = new Set(['[', '.']);
// cases where traversal is A-OK, no dot prevention needed
const justDots = new Set(['..', '.']);
const reSpecials = new Set('().*{}+?[]^$\\!');
const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
// any single thing other than /
const qmark = '[^/]';
// * => any number of characters
const star = qmark + '*?';
// use + when we need to ensure that *something* matches, because the * is
// the only thing in the path portion.
const starNoEmpty = qmark + '+?';
// remove the \ chars that we added if we end up doing a nonmagic compare
// const deslash = (s: string) => s.replace(/\\(.)/g, '$1')
class AST {
    type;
    #root;
    #hasMagic;
    #uflag = false;
    #parts = [];
    #parent;
    #parentIndex;
    #negs;
    #filledNegs = false;
    #options;
    #toString;
    // set to true if it's an extglob with no children
    // (which really means one child of '')
    #emptyExt = false;
    constructor(type, parent, options = {}) {
        this.type = type;
        // extglobs are inherently magical
        if (type)
            this.#hasMagic = true;
        this.#parent = parent;
        this.#root = this.#parent ? this.#parent.#root : this;
        this.#options = this.#root === this ? options : this.#root.#options;
        this.#negs = this.#root === this ? [] : this.#root.#negs;
        if (type === '!' && !this.#root.#filledNegs)
            this.#negs.push(this);
        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
    }
    get hasMagic() {
        /* c8 ignore start */
        if (this.#hasMagic !== undefined)
            return this.#hasMagic;
        /* c8 ignore stop */
        for (const p of this.#parts) {
            if (typeof p === 'string')
                continue;
            if (p.type || p.hasMagic)
                return (this.#hasMagic = true);
        }
        // note: will be undefined until we generate the regexp src and find out
        return this.#hasMagic;
    }
    // reconstructs the pattern
    toString() {
        if (this.#toString !== undefined)
            return this.#toString;
        if (!this.type) {
            return (this.#toString = this.#parts.map(p => String(p)).join(''));
        }
        else {
            return (this.#toString =
                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');
        }
    }
    #fillNegs() {
        /* c8 ignore start */
        if (this !== this.#root)
            throw new Error('should only call on root');
        if (this.#filledNegs)
            return this;
        /* c8 ignore stop */
        // call toString() once to fill this out
        this.toString();
        this.#filledNegs = true;
        let n;
        while ((n = this.#negs.pop())) {
            if (n.type !== '!')
                continue;
            // walk up the tree, appending everthing that comes AFTER parentIndex
            let p = n;
            let pp = p.#parent;
            while (pp) {
                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {
                    for (const part of n.#parts) {
                        /* c8 ignore start */
                        if (typeof part === 'string') {
                            throw new Error('string part in extglob AST??');
                        }
                        /* c8 ignore stop */
                        part.copyIn(pp.#parts[i]);
                    }
                }
                p = pp;
                pp = p.#parent;
            }
        }
        return this;
    }
    push(...parts) {
        for (const p of parts) {
            if (p === '')
                continue;
            /* c8 ignore start */
            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {
                throw new Error('invalid part: ' + p);
            }
            /* c8 ignore stop */
            this.#parts.push(p);
        }
    }
    toJSON() {
        const ret = this.type === null
            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))
            : [this.type, ...this.#parts.map(p => p.toJSON())];
        if (this.isStart() && !this.type)
            ret.unshift([]);
        if (this.isEnd() &&
            (this === this.#root ||
                (this.#root.#filledNegs && this.#parent?.type === '!'))) {
            ret.push({});
        }
        return ret;
    }
    isStart() {
        if (this.#root === this)
            return true;
        // if (this.type) return !!this.#parent?.isStart()
        if (!this.#parent?.isStart())
            return false;
        if (this.#parentIndex === 0)
            return true;
        // if everything AHEAD of this is a negation, then it's still the "start"
        const p = this.#parent;
        for (let i = 0; i < this.#parentIndex; i++) {
            const pp = p.#parts[i];
            if (!(pp instanceof AST && pp.type === '!')) {
                return false;
            }
        }
        return true;
    }
    isEnd() {
        if (this.#root === this)
            return true;
        if (this.#parent?.type === '!')
            return true;
        if (!this.#parent?.isEnd())
            return false;
        if (!this.type)
            return this.#parent?.isEnd();
        // if not root, it'll always have a parent
        /* c8 ignore start */
        const pl = this.#parent ? this.#parent.#parts.length : 0;
        /* c8 ignore stop */
        return this.#parentIndex === pl - 1;
    }
    copyIn(part) {
        if (typeof part === 'string')
            this.push(part);
        else
            this.push(part.clone(this));
    }
    clone(parent) {
        const c = new AST(this.type, parent);
        for (const p of this.#parts) {
            c.copyIn(p);
        }
        return c;
    }
    static #parseAST(str, ast, pos, opt) {
        let escaping = false;
        let inBrace = false;
        let braceStart = -1;
        let braceNeg = false;
        if (ast.type === null) {
            // outside of a extglob, append until we find a start
            let i = pos;
            let acc = '';
            while (i < str.length) {
                const c = str.charAt(i++);
                // still accumulate escapes at this point, but we do ignore
                // starts that are escaped
                if (escaping || c === '\\') {
                    escaping = !escaping;
                    acc += c;
                    continue;
                }
                if (inBrace) {
                    if (i === braceStart + 1) {
                        if (c === '^' || c === '!') {
                            braceNeg = true;
                        }
                    }
                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                        inBrace = false;
                    }
                    acc += c;
                    continue;
                }
                else if (c === '[') {
                    inBrace = true;
                    braceStart = i;
                    braceNeg = false;
                    acc += c;
                    continue;
                }
                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {
                    ast.push(acc);
                    acc = '';
                    const ext = new AST(c, ast);
                    i = AST.#parseAST(str, ext, i, opt);
                    ast.push(ext);
                    continue;
                }
                acc += c;
            }
            ast.push(acc);
            return i;
        }
        // some kind of extglob, pos is at the (
        // find the next | or )
        let i = pos + 1;
        let part = new AST(null, ast);
        const parts = [];
        let acc = '';
        while (i < str.length) {
            const c = str.charAt(i++);
            // still accumulate escapes at this point, but we do ignore
            // starts that are escaped
            if (escaping || c === '\\') {
                escaping = !escaping;
                acc += c;
                continue;
            }
            if (inBrace) {
                if (i === braceStart + 1) {
                    if (c === '^' || c === '!') {
                        braceNeg = true;
                    }
                }
                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                    inBrace = false;
                }
                acc += c;
                continue;
            }
            else if (c === '[') {
                inBrace = true;
                braceStart = i;
                braceNeg = false;
                acc += c;
                continue;
            }
            if (isExtglobType(c) && str.charAt(i) === '(') {
                part.push(acc);
                acc = '';
                const ext = new AST(c, part);
                part.push(ext);
                i = AST.#parseAST(str, ext, i, opt);
                continue;
            }
            if (c === '|') {
                part.push(acc);
                acc = '';
                parts.push(part);
                part = new AST(null, ast);
                continue;
            }
            if (c === ')') {
                if (acc === '' && ast.#parts.length === 0) {
                    ast.#emptyExt = true;
                }
                part.push(acc);
                acc = '';
                ast.push(...parts, part);
                return i;
            }
            acc += c;
        }
        // unfinished extglob
        // if we got here, it was a malformed extglob! not an extglob, but
        // maybe something else in there.
        ast.type = null;
        ast.#hasMagic = undefined;
        ast.#parts = [str.substring(pos - 1)];
        return i;
    }
    static fromGlob(pattern, options = {}) {
        const ast = new AST(null, undefined, options);
        AST.#parseAST(pattern, ast, 0, options);
        return ast;
    }
    // returns the regular expression if there's magic, or the unescaped
    // string if not.
    toMMPattern() {
        // should only be called on root
        /* c8 ignore start */
        if (this !== this.#root)
            return this.#root.toMMPattern();
        /* c8 ignore stop */
        const glob = this.toString();
        const [re, body, hasMagic, uflag] = this.toRegExpSource();
        // if we're in nocase mode, and not nocaseMagicOnly, then we do
        // still need a regular expression if we have to case-insensitively
        // match capital/lowercase characters.
        const anyMagic = hasMagic ||
            this.#hasMagic ||
            (this.#options.nocase &&
                !this.#options.nocaseMagicOnly &&
                glob.toUpperCase() !== glob.toLowerCase());
        if (!anyMagic) {
            return body;
        }
        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');
        return Object.assign(new RegExp(`^${re}$`, flags), {
            _src: re,
            _glob: glob,
        });
    }
    get options() {
        return this.#options;
    }
    // returns the string match, the regexp source, whether there's magic
    // in the regexp (so a regular expression is required) and whether or
    // not the uflag is needed for the regular expression (for posix classes)
    // TODO: instead of injecting the start/end at this point, just return
    // the BODY of the regexp, along with the start/end portions suitable
    // for binding the start/end in either a joined full-path makeRe context
    // (where we bind to (^|/), or a standalone matchPart context (where
    // we bind to ^, and not /).  Otherwise slashes get duped!
    //
    // In part-matching mode, the start is:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: ^(?!\.\.?$)
    // - if dots allowed or not possible: ^
    // - if dots possible and not allowed: ^(?!\.)
    // end is:
    // - if not isEnd(): nothing
    // - else: $
    //
    // In full-path matching mode, we put the slash at the START of the
    // pattern, so start is:
    // - if first pattern: same as part-matching mode
    // - if not isStart(): nothing
    // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
    // - if dots allowed or not possible: /
    // - if dots possible and not allowed: /(?!\.)
    // end is:
    // - if last pattern, same as part-matching mode
    // - else nothing
    //
    // Always put the (?:$|/) on negated tails, though, because that has to be
    // there to bind the end of the negated pattern portion, and it's easier to
    // just stick it in now rather than try to inject it later in the middle of
    // the pattern.
    //
    // We can just always return the same end, and leave it up to the caller
    // to know whether it's going to be used joined or in parts.
    // And, if the start is adjusted slightly, can do the same there:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
    // - if dots allowed or not possible: (?:/|^)
    // - if dots possible and not allowed: (?:/|^)(?!\.)
    //
    // But it's better to have a simpler binding without a conditional, for
    // performance, so probably better to return both start options.
    //
    // Then the caller just ignores the end if it's not the first pattern,
    // and the start always gets applied.
    //
    // But that's always going to be $ if it's the ending pattern, or nothing,
    // so the caller can just attach $ at the end of the pattern when building.
    //
    // So the todo is:
    // - better detect what kind of start is needed
    // - return both flavors of starting pattern
    // - attach $ at the end of the pattern when creating the actual RegExp
    //
    // Ah, but wait, no, that all only applies to the root when the first pattern
    // is not an extglob. If the first pattern IS an extglob, then we need all
    // that dot prevention biz to live in the extglob portions, because eg
    // +(*|.x*) can match .xy but not .yx.
    //
    // So, return the two flavors if it's #root and the first child is not an
    // AST, otherwise leave it to the child AST to handle it, and there,
    // use the (?:^|/) style of start binding.
    //
    // Even simplified further:
    // - Since the start for a join is eg /(?!\.) and the start for a part
    // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
    // or start or whatever) and prepend ^ or / at the Regexp construction.
    toRegExpSource(allowDot) {
        const dot = allowDot ?? !!this.#options.dot;
        if (this.#root === this)
            this.#fillNegs();
        if (!this.type) {
            const noEmpty = this.isStart() && this.isEnd();
            const src = this.#parts
                .map(p => {
                const [re, _, hasMagic, uflag] = typeof p === 'string'
                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)
                    : p.toRegExpSource(allowDot);
                this.#hasMagic = this.#hasMagic || hasMagic;
                this.#uflag = this.#uflag || uflag;
                return re;
            })
                .join('');
            let start = '';
            if (this.isStart()) {
                if (typeof this.#parts[0] === 'string') {
                    // this is the string that will match the start of the pattern,
                    // so we need to prot<_úG2™›˜i4\øGf–UÉ@æ2²ì.ù,eÚ×) È~Ò6]yì
n_*ú¹¶ÕÑşÌ}­Ön=4Øp†ñ? f>Nœ‡ é Ò*ø•õ)î!éùL¤¹BÒ¶øG^–¾dÒä¤¢æÏä½©¾µA@¶‡´ü#¿œ|£|$Ê±¤Û/Ğ[â’ĞÌêÎš„.¼Å¾]‚XÅÅé9+’1â6›Ã
5Êj£—|r¨—Â@Ú@Ò­Ù×›Ë*Ä,ñËc½€bJ+sâGêŠ0Ø€ırıœp0‚ÃèàÍKurÊ>kä·9ì»¾#²×Í¶˜âc09l”ô!á&Ë`}8È€½dBß_lÃÃŒ„bjm]ğÍ
Æñ¨‡OyS:Ü‹"ğ.õÂ™1xåg}g÷UñüDûÛ“ĞGàçŸN>”Çøá>Å×îøÇ••ë¸ŒoTVÆH¯îßö_}5.„sğ¼?g²rZ`½ÖÇ¸ÕŠÇ_¢FHòFŒÿ7ù°gcôøHé'…¶ùtC&oVLùNÒÅãS‡RÁÃ	ûÖç)¼r°WßI%>xÂÉ¾üû¥¦#V‰Ğpºü?Rr#û §Rûà*éúîH)ÄÖÉ}Çí
;öğ€ÀPÇâøË,Ç/ ÖÎæü Õ‚S2z«À:Ÿ£ßóƒ^íûÿ<Ğ[ECrÆß¶"5â}Š¿LØ‚oÀÍò¾C€²ã(yğ—²ã'(yğ÷ü_ğ„#şzï˜ U>Çò&şk…Õ}†#ÿWİ‹÷_QMëFôVbH¾µñ\[¦7>OÔ;N<î¾²å7É‰m¸Í5í"ÁfÑòÊš'<ü_É “ÿ—,Ä
üÿÉ%ÚÔÿ?¹eà=úÿ'UÉ†ÔÜ
äø+”8ÃËÎÏAƒp)ëâ}rŠ6·(Wg‹Óô_ÉÃ÷m·!Â+5RËOÅˆÿ&	£°¦Œ{=;m3ì¾ ~ ¼ı,œP¦6,éÏìòM€ô|·xûàåW|%ªÖ;`‚Û~“äP{üÕ
bÒ£3[%#F õ{îCú¢˜ş‡'ÒŞŞ¸6«‡‡åğfÁaÌä*ğ•ï-Ø,½)òÒ6çÙ{ËcÃ8İ‰æE½{K°k—½TA4H;P¼«rröî‡\ãîlBb@ÎLmİKÙ‰‰HüÆ§“~şÇi0§+¢î>NpÌ²ÙE‰"P?f„sFì |“/}LÚyÊfW'?Ó¡æ4˜ á§:h¸©äútDÂIõĞÉ‚‚&ˆKeäı-Ï‰øuë¦á=  ¡º6ÉîrcÒgÈéÏRtpãê~vu„ãıD†ÊÇÉ¬Ş!ğóKd=%&Q+õ÷ßBuĞ¾=#W6Ú†Ï~”Uc©RGj°U¨ Ä®¬Tü&Iv×ÈOÂ§½l*$/l>bs\xz"¦.“_¾ì=ÍÏ²Ê
Y—#'Iœ˜c¼3=7A(áÁ“Iİİ¯/!}ËQòìÏ(¤—e½^t1åu¼Û®:{}©…=M++wÆ&ñ	sÏyŠdòpl
Ÿ+ÿ™ÓB'§Hk‘’«x¢jË£B—V_‘üğìS.OŸŸ"Üñš†@ôP,J§é™ÆkİİxÈ1pÅõ2Œ†`o—aåtññ#úŞi8«Š{oõ«Á¯Ùşà+­Ø{ˆÊŸßS2Î	è'Œ˜ø/©J”uT^Àj&^oÖ=ë8áóŞ~D¢ò¤S)c©Ö|ğÌÎŠi“’,dÿàÍpæÇH¦GÁ3×WVf4ÿ¸»jÿüĞV­Øh_ï+Å}0¨ÎHÒ±&¬I.‰Û&2Cb¨J›†À]ºænëái‡ºfğaH.c×Y>-Ä¡o[¸™ËöòAï‹>SÄYÿÌàot<¦ö&øO«b=K¬]{Û9$¯ËÏÍxĞõ{šzŞÜİwÑÎoŸj¦‘16®¿$¹P[ü¯ Ê­¸SÀ|>s(¦;íkôqOİÔÚïX‚Ğ_<õ–Ø¯‰÷Ë+>°‰ôMzö4ê·Òo×Ë%%ÕûoÎÛ	4ãÀ+Ş@úu@*·•¬uxİÂO2s ›",S©_7í)øPµ¥‘Ûù‚è. ‡ËŞ¥1R7A™±ÂÎÄnr)â"SûaœŒ™ˆı%ÑÂ.ãQúbj7ÏóDŠ„FÆƒ*Ğãë)O.ìø‹· ?Ş‚³¿ •2ŸŸ„²KvíZ‚#·'JÃ›Ñøö—(7f½Áœ;$³Ô†UM}'Itƒd˜t“ŠBñ’øí=ûçeà=/¼p‰wz*á/|óºúõûWLˆe/‰A´‰ÜU3Vw\`O"‘¨ˆú•%ÊŸğ p­-®×yá‘Aß¡Ñ¬œ:»ÉX´²^æä´Ô=EÌmöMeaá	Iê–Å: ;"$ãr§*³‰{<>é&ûµ5Xß³Ò›°* 3à¶µÀEòÒô—²Í+«¥TêŞz3tæà,nqĞú0Š¨©ÿ:ÓÇØR}ÿˆlf7ú	jú†õZBƒAMr\6ÿ±¼5ÂJsXOï¸×
§äÇ)A9æ³x+ï?Éˆ}TDd”ÂüæõUÂ¶òsèÂéÜâî;ö‚å ¹Ò4î]p=B~¾[pênK{Ü5  ‰PröLsÓİx±õD"AA*¥¶äMŠ;@”ùy¼Âu‚‚4şHKWÃT¹ë0&¯ÿ.¤òP,¨O/ûQa:¾˜ƒ­š×©‚¦Z”Ñå1g^ê6ÿ7B\,‚ĞÜíFj3áó@·ëo
ˆy²ğµù‹ÇÙ­¤ê€É7@§ªj…¿ÆW×Œ¬i|»‘ˆ„@"c÷ìêI²*@‡>±\Q©ç^÷q½Y
-t@ê
ëùô¬£òûÃ¿ÿ¬?kò0(HBXñĞÅ«4e†ŞĞßÁ¡ï‰q	R­e:HBËWÚäíBÑ& Q>…ß_„Ä3Où4 ‹ııBI&0Hƒ™æpšnnjğG?Í}AË2Ê™h2d"³E€F¼Ê?iãÖ“uˆ´ ½î˜#1£)éSW|k®±Ò‰§oKş’±xü_ô(ÑÑ‹Œ©µ¯Ï-Ë©X–,äÚjªúÀĞqù×Ìº9|+Hd,Ñ³ŠÄ€FoŸ£°^Ó—UVî3+Ã—v\‰ˆ“ø^`±Y¿‹2{Rs_Öœäw
‰jë_ÿI×f 2	÷³æF&DòäV±´ #’wSÖÍ
naA=)3®Ø
tØŸÈøBÇÿ
ñ[íxµ³‰©½§ÎıhäH©}˜ïzôT« ä RMå2PÿNÃ×’ªûDÉÌe"g=rÉöEì–Bò–µö‰ımeË£(4‡/
Uõ$NÔ¡¨uàÏÈ$ÊÓkçÂæp×Çr°êñÀvÏÃ“/Á ’w[Ì1Ñ›@<ƒã=L$H™1—ü¹¶¸0ä'A.–%ö¯JæÄ®Ü‹d*ÑõV½Bÿ“ìdxı¿ÚÄt€ü vzp•Ğ£6Í/"dìÅP<Ñ—.2È
Å‰ šeM»3xâ²@tÑ— QŞ¦Èæ@ş‡òh™?\>û>Ô^J¦ß¯ŸUÕ@-Õn¼÷î÷ïOü¹!1H½q“@_Í7TÂàÓŒşrau®ƒ´Ùúh ó³×cgø™E®VDœà
’VdëĞÁË©ïnµÿÒŞ«:i0Hä/Ğ±”f_İ¡–+XË×/àœéN~6JBKsxŒvá1¹3yÎ/tcÓŞ
ıİ„Â%X½<ÉM8ÔEæp7 HÿÈï¸»){ö®ä‚ÓXçñòæeZ>‚çáji <H&1M\@Ït|£Sˆó-K:ÂÉO1jÂ·ˆ¡cùiûPéÜ„Ö
AAŒ‘úö mr~0mïÜBäRdÀ»}@ùlznˆüä—õÉ/$(H!§Ì“ÄÑ³h’cñXGÄ”áÃÏğ{5\>Œ9ë+·(«ËËİ~³6<WËÕí½"C¤o<c1‰†ÅıGÉÄs0ÛQGiSsù à;·y\}múóŠÖFhÇŞá$/„$ «‹ïˆ¼«Ø¯ÑsV˜ÿ(/¾³ çS–â´Lh_Lfbáàõå>ïÓı†´?%vLğÙ(eÒ<ƒSí5ŞzÕ4Uo Ú)¦Ù›¹"šFÕöPÏØä…Óì>ägÿ©nÿCÏvÛñ¸¿ê¬@i°ŞqĞ8{™Ï¨ºÊùÅïí2¼¬ ½ÒuÛ
ûLKQ¼Š¶çÍÔ(½ÁhÚÍ}12İ™=Ôraü~„İgóºEo;¬3zä±ÒÀôqYWP(°ú
hÇ^–o0®g`˜h÷å!´3*Î/é:>´S-ø0ö‚I¨©\ãÑ$í£7hü ¼ëÁµÊ×±Æü$;VŒ“.¨ÿ¶ÑôÙèï:ÜR`L–´lòí;RA{±æİkTö’Ñ&t¶%ÔPè‡NØvÛú¾J« WŒ/ íøy¤ëÍy[µşİçßÌ„%û'šc®´®•uy}¨WØçëÖÑ+¢VÂÑ‰ó¤mÈx.Æìà˜ÔTa7f(PsQÖ¾õLâ»mO{¾ú7»æx|³¥ó{de+yöî¨ø•€Kt ~4çÕá¿äoõ=´\©Œ«ó}n{$°¡’yÒV 6qÖ§ğÇ°MÕ‡XÂÓ©mtf	%çv×j›^¿K¿‰!Œ³²övK¼Ô¹S'_<¯éL¼¡6³;×NwèSñ¼yoÇš5²¨[ê"Mà1N"æ/‹l	6[ĞÚWEdm»ë÷|ŠïñƒV™!{~í`8zi:<$²vdˆTÜNúrK»¼ârj^“hÁ¯:br!ƒWËìé,¥Æxnï¿&uŞ“;¹àä›%åzò­$‘ï]«ÑÈt¾ ïƒ/eC“Üßök—|–Ij€Öãóç—æ|½á.5eë1xîìÛ” ï“VîU.pø}ñ¡ÖŞé°Êw`tC;CèÛSGò«¼ü*ˆ8±í£¥Ş/ãşÛ?Â3k­¢ä
£“_ø÷vĞvy/ßğ„­2âE]Ñ5LZÜMY5$•è•°WËôP»w:Í¥´Ïg'4³û«<—ˆĞ™&ò+±ŒKäSµàúÊdÿV¶²M²êª1Æö´ÃŒô’9ø¹Ü×¿j ªÉï!"#ÖPW$ ï¥³>bäuHÂÖpkB›'ÕñVxgí¤³_q¦ÍöñÜcŸTõqÖ'>H»U¤”w8@ñ'4ÊóÜ“™Síövò½q¼Dcoü¼÷«Rãİúñk—¼îìÖÏY·B¹@óı=OÚ,õßY7+ú‚Ô?›Èêœº›rZvşQ:gŸòR=s‡á¼o"‚ÿL5ş¼÷ï.8–Û`^ÒHØ.¶`N“¦´­`âÃrVÅxMÕó³rï¨´yĞş¼7*/Ë®Åù“\äkBûıué’‘?õx
;¼’Ÿy[óe“Aoˆá"h«7&|Ï~e¸)‘VN´ù£’œÅJ	9Kµí&v,)ûSHfCArô¸öW‰G¥²‚›üîmÙH´y»é·Q#‰ƒIÒ=NXš÷”ÜV:"Ä
ÚŞ”ÈJEïÆÁkµ|„%CÙÈ+*™º²÷Í È˜»û‘›Z³±,î¼·eª¢-J-í\>D-Q¦ÚmåŸéâ¼yµãÓTôÇÎ.×sQ(Aú< ~’MöeÔ1ó–fÉ~Âğí¬Dï¿¾î^ìJl“ÅÈ®åµŒ}»àAPï-å¯/jú'e¿¹>q)/×®°fƒè¾ƒ|4¥6%ù´—	ïš–(ŞØú`:ß¦~Í‡µß6Ì‰¬ufªêÁ‘©„Çæıü$ÿ]>úù·GbR7@æ–2]ªB÷µ¹íQŒ"L?;ÂøwÿÉ{·2§³XÊßò¤)?|J™Š’õß‘¯B·¦¿Ûœïi2K´â÷7ç¿q=?²'˜ÌÌ'õI‰®ü®¥ê½lùôô‹$«î.ã ¶ÕIÄ;¼™%`§^À%ÃŞ¨jò›¥=ş?´ööG^Ã^,8×ªú,#,—>VœÜ°%ãû_"±ÇÅõoÔŒV> ÚÓİ1SŸ«´îú<¾ìğ‘è¢rOÙ{_lŞ*÷ş,*ÕBCë…H€ßQĞ.|¼yÖƒlëz±Şş1Ñˆ»Ï‹„á˜ØrÔô²u¯«^¥ş»'¡iÆ ­šŞ¹”Rrƒ|Yªg	1Äş®;téhøá	…±Ä™Ç¯•˜Jx–2Ìğ8Êˆ­[ÓoX£>Ğ¬üğ<¦ÃƒÃ1§ïÃ¸æÕƒZ¬#û©ŠT IìLBCšêjgxŞ¿õ$à`PÙ¢—û›ú»Çšƒ†!pMvğÓHo%Úhşù|¦ÙÚCòtÉ„Swu<5B‹(ªÔÓ×”]H{À9¨p{ğM¼@XÆÁ€9ı]"uü*ƒ¬c™Òèæ·Ëïl%• C]<kö›3	–o*Ê³¨¯y¡×ãÖè­ˆ/[8<Ş|êú¶·@öv‹”qÛË0>@‹pCw±Zö¾¯Ùıx<øØC)2KNŸé”pË‡Sˆ¼ß¸(—âœ™q|¿ğúsyJ?=å‹ºµ;¾Ããa‹§¬¬
-’¶¤'ƒ_bx¬ã:I7-‡.Ş…0MşOe)’£p7 ÃÕë†på^®ÎSÌ-ThÓ ÓU{õ"Iq/>½¡ŒõLj,Wp£"Yœ~/ã&nÈr.×ÜãHÙµ$´KÕk/cöã²	zI¬°šŞĞ,ãºòíml şg .É¦QÔØÕ02T&àißÍíÿ~¯o hù]ËÆ¬ó†sä·HŞ9ÖÉüQ&»‘u	ö­3ÓÃ!.ı†Û+èP?„æ¬õş[–ä–Hüh¹øğØŞMæêØôf„œpúb•Ğ¨%ù`;—HÜ(2d½Ş¹üË>ÈZÇ>;âè°'Á-x¯Æ®„>R„"”üÑßÊ6ğë5F=âˆ3Ä²Jİ¼o	nº\ıÆ%>å‡(·šR¾}·cZ«e’ä`Ô´%€Š-ÁE>Ï^¿	 ½‘‚ZzŠ›Ëô7#qâĞP„õ™eDL8ĞPªõş‡M³|vEf@Gßòõsİı•”u,ôqZA {iŸ’"Şû¾óMé”jôï}’ioì>.åPíG}ôPC*3ƒõèÍõ+x©§
ĞmÏÑ°ÅëùmonMÔm½Æ€DjäØ5'ÿBAm‹5tph:¤zşú|oíx£‡)-B®Ù™è…s†¸ß©7Ê²ªvÑ!Ñ_†í«îWVúøW<’¡şnw¡@*Â!×‚¿QôââşüM!7‘"Ü)4šß¶‰LUYêS‰6o.×ø¥~oê0œzÏ˜,RÕ–¦­cHºùLáºÍéxä	?	}m±‚ör¨BëN¦l:Ã],:ÁlÈ(udI[„J#/ãôƒ‚s´€Ç×OŞVt‡áœ¯g.¯@‰šAT)_‹å±ËYŞõö2F'pªèBQĞÃºènÿ®ÇbbÌ”¶ÏîDØ„;q t¢I–Œ9½^ iQe@§}~kúÎxÿ¤êó}Oâaãd÷ééÀb'#P¦k?Ù‘™ Ë#ÿØgçqºÙaâ‚
í2Û2IíÑˆá¨¤û“\ÙmÇ‹Dñq#*ñkW EÀ€ZÄ©3¶æ|RÕyDã`-òÚ‹ó¹ŒhçİTÎğ\^×FL'‘µ(N«/W¼mÂ\ÊX—Î•níaôëâ+åeS8‘°ß–Š©r/ããWå-öi¯w*IªÄºêlÂÜqµ]¬õİ”Z-äâ]òšÇÙx{ş—8ÏÍ¨üÉƒL™E˜?Ğ'"ŞÃßh{ùš×?A^Ğã MĞÈ@Ç6éñ_™Ë»òò¼b^3¼o”o/ŒaÓB@?s”òs¯İé&¸Ñm#š€W†N-³~ê¼¼veéwH‚Ğã/nûo^íñ€£J0ÊoåtÌ¿qÛ;f®G1‘D„\$SM7@uŠ¯v
é«qC‘Ğcä|– óË¤è[İZòˆğ½-¶×î]“'!ÑÄ{‰‡½n¹Ík³ç³wìúˆ&øñ„
Æ{Êù ŠØ2>½ÜÕ±ù­`·L ×úÂ[U»uö}A/¡¿SÏµ¦¾ìûôÙ† û£[ëO""$îú#8‚eí ë˜¤/m$óOUİ}çjhEp·Õíå(5F
{õÏmŒau÷