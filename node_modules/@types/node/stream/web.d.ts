type _ByteLengthQueuingStrategy = typeof globalThis extends { onmessage: any } ? {}
    : import("stream/web").ByteLengthQueuingStrategy;
type _CompressionStream = typeof globalThis extends { onmessage: any; ReportingObserver: any } ? {}
    : import("stream/web").CompressionStream;
type _CountQueuingStrategy = typeof globalThis extends { onmessage: any } ? {}
    : import("stream/web").CountQueuingStrategy;
type _DecompressionStream = typeof globalThis extends { onmessage: any; ReportingObserver: any } ? {}
    : import("stream/web").DecompressionStream;
type _ReadableByteStreamController = typeof globalThis extends { onmessage: any } ? {}
    : import("stream/web").ReadableByteStreamController;
type _ReadableStream<R = any> = typeof globalThis extends { onmessage: any } ? {}
    : import("stream/web").ReadableStream<R>;
type _ReadableStreamBYOBReader = typeof globalThis extends { onmessage: any } ? {}
    : import("stream/web").ReadableStreamBYOBReader;
type _ReadableStreamBYOBRequest = typeof globalThis extends { onmessage: any } ? {}
    : import("stream/web").ReadableStreamBYOBRequest;
type _ReadableStreamDefaultController<R = any> = typeof globalThis extends { onmessage: any } ? {}
    : import("stream/web").ReadableStreamDefaultController<R>;
type _ReadableStreamDefaultReader<R = any> = typeof globalThis extends { onmessage: any } ? {}
    : import("stream/web").ReadableStreamDefaultReader<R>;
type _TextDecoderStream = typeof globalThis extends { onmessage: any } ? {}
    : import("stream/web").TextDecoderStream;
type _TextEncoderStream = typeof globalThis extends { onmessage: any } ? {}
    : import("stream/web").TextEncoderStream;
type _TransformStream<I = any, O = any> = typeof globalThis extends { onmessage: any } ? {}
    : import("stream/web").TransformStream<I, O>;
type _TransformStreamDefaultController<O = any> = typeof globalThis extends { onmessage: any } ? {}
    : import("stream/web").TransformStreamDefaultController<O>;
type _WritableStream<W = any> = typeof globalThis extends { onmessage: any } ? {}
    : import("stream/web").WritableStream<W>;
type _WritableStreamDefaultController = typeof globalThis extends { onmessage: any } ? {}
    : import("stream/web").WritableStreamDefaultController;
type _WritableStreamDefaultWriter<W = any> = typeof globalThis extends { onmessage: any } ? {}
    : import("stream/web").WritableStreamDefaultWriter<W>;

declare module "stream/web" {
    // stub module, pending copy&paste from .d.ts or manual impl
    // copy from lib.dom.d.ts
    interface ReadableWritablePair<R = any, W = any> {
        readable: ReadableStream<R>;
        /**
         * Provides a convenient, chainable way of piping this readable stream
         * through a transform stream (or any other { writable, readable }
         * pair). It simply pipes the stream into the writable side of the
         * supplied pair, and returns the readable side for further use.
         *
         * Piping a stream will lock it for the duration of the pipe, preventing
         * any other consumer from acquiring a reader.
         */
        writable: WritableStream<W>;
    }
    interface StreamPipeOptions {
        preventAbort?: boolean;
        preventCancel?: boolean;
        /**
         * Pipes this readable stream to a given writable stream destination.
         * The way in which the piping process behaves under various error
         * conditions can be customized with a number of passed options. It
         * returns a promise that fulfills when the piping process completes
         * successfully, or rejects if any errors were encountered.
         *
         * Piping a stream will lock it for the duration of the pipe, preventing
         * any other consumer from acquiring a reader.
         *
         * Errors and closures of the source and destination streams propagate
         * as follows:
         *
         * An error in this source readable stream will abort destination,
         * unless preventAbort is truthy. The returned promise will be rejected
         * with the source's error, or with any error that occurs during
         * aborting the destination.
         *
         * An error in destination will cancel this source readable stream,
         * unless preventCancel is truthy. The returned promise will be rejected
         * with the destination's error, or with any error that occurs during
         * canceling the source.
         *
         * When this source readable stream closes, destination will be closed,
         * unless preventClose is truthy. The returned promise will be fulfilled
         * once this process completes, unless an error is encountered while
         * closing the destination, in which case it will be rejected with that
         * error.
         *
         * If destination starts out closed or closing, this source readable
         * stream will be canceled, unless preventCancel is true. The returned
         * promise will be rejected with an error indicating piping to a closed
         * stream failed, or with any error that occurs during canceling the
         * source.
         *
         * The signal option can be set to an AbortSignal to allow aborting an
         * ongoing pipe operation via the corresponding AbortController. In this
         * case, this source readable stream will be canceled, and destination
         * aborted, unless the respective options preventCancel or preventAbort
         * are set.
         */
        preventClose?: boolean;
        signal?: AbortSignal;
    }
    interface ReadableStreamGenericReader {
        readonly closed: Promise<undefined>;
        cancel(reason?: any): Promise<void>;
    }
    type ReadableStreamController<T> = ReadableStreamDefaultController<T>;
    interface ReadableStreamReadValueResult<T> {
        done: false;
        value: T;
    }
    interface ReadableStreamReadDoneResult<T> {
        done: true;
        value?: T;
    }
    type ReadableStreamReadResult<T> = ReadableStreamReadValueResult<T> | ReadableStreamReadDoneResult<T>;
    interface ReadableByteStreamControllerCallback {
        (controller: ReadableByteStreamController): void | PromiseLike<void>;
    }
    interface UnderlyingSinkAbortCallback {
        (reason?: any): void | PromiseLike<void>;
    }
    interface UnderlyingSinkCloseCallback {
        (): void | PromiseLike<void>;
    }
    interface UnderlyingSinkStartCallback {
        (controller: WritableStreamDefaultController): any;
    }
    interface UnderlyingSinkWriteCallback<W> {
        (chunk: W, controller: WritableStreamDefaultController): void | PromiseLike<void>;
    }
    interface UnderlyingSourceCancelCallback {
        (reason?: any): void | PromiseLike<void>;
    }
    interface UnderlyingSourcePullCallback<R> {
        (controller: ReadableStreamController<R>): void | PromiseLike<void>;
    }
    interface UnderlyingSourceStartCallback<R> {
        (controller: ReadableStreamController<R>): any;
    }
    interface TransformerFlushCallback<O> {
        (controller: TransformStreamDefaultController<O>): void | PromiseLike<void>;
    }
    interface TransformerStartCallback<O> {
        (controller: TransformStreamDefaultController<O>): any;
    }
    interface TransformerTransformCallback<I, O> {
        (chunk: I, controller: TransformStreamDefaultController<O>): void | PromiseLike<void>;
    }
    interface UnderlyingByteSource {
        autoAllocateChunkSize?: number;
        cancel?: ReadableStreamErrorCallback;
        pull?: ReadableByteStreamControllerCallback;
        start?: ReadableByteStreamControllerCallback;
        type: "bytes";
    }
    interface UnderlyingSource<R = any> {
        cancel?: UnderlyingSourceCancelCallback;
        pull?: UnderlyingSourcePullCallback<R>;
        start?: UnderlyingSourceStartCallback<R>;
        type?: undefined;
    }
    interface UnderlyingSink<W = any> {
        abort?: UnderlyingSinkAbortCallback;
        close?: UnderlyingSinkCloseCallback;
        start?: UnderlyingSinkStartCallback;
        type?: undefined;
        write?: UnderlyingSinkWriteCallback<W>;
    }
    interface ReadableStreamErrorCallback {
        (reason: any): void | PromiseLike<void>;
    }
    /** This Streams API interface represents a readable stream of byte data. */
    interface ReadableStream<R = any> {
        readonly locked: boolean;
        cancel(reason?: any): Promise<void>;
        getReader(options: { mode: "byob" }): ReadableStreamBYOBReader;
        getReader(): ReadableStreamDefaultReader<R>;
        getReader(options?: ReadableStreamGetReaderOptions): ReadableStreamReader<R>;
        pipeThrough<T>(transform: ReadableWritablePair<T, R>, options?: StreamPipeOptions): ReadableStream<T>;
        pipeTo(destination: WritableStream<R>, options?: StreamPipeOptions): Promise<void>;
        tee(): [ReadableStream<R>, ReadableStream<R>];
        values(options?: { preventCancel?: boolean }): AsyncIterableIterator<R>;
        [Symbol.asyncIterator](): AsyncIterableIterator<R>;
    }
    const ReadableStream: {
        prototype: ReadableStream;
        from<T>(iterable: Iterable<T> | AsyncIterable<T>): ReadableStream<T>;
        new(underlyingSource: UnderlyingByteSource, strategy?: QueuingStrategy<Uint8Array>): ReadableStream<Uint8Array>;
        new<R = any>(underlyingSource?: UnderlyingSource<R>, strategy?: QueuingStrategy<R>): ReadableStream<R>;
    };
    type ReadableStreamReaderMode = "byob";
    interface ReadableStreamGetReaderOptions {
        /**
         * Creates a ReadableStreamBYOBReader and locks the stream to the new reader.
         *
         * This call behaves the same way as the no-argument variant, except that it only works on readable byte streams, i.e. streams which were constructed specifically with the ability to handle "bring your own buffer" reading. The returned BYOB reader provides the ability to directly read individual chunks from the stream via its read() method, into developer-supplied buffers, allowing more precise control over allocation.
         */
        mode?: ReadableStreamReaderMode;
    }
    type ReadableStreamReader<T> = ReadableStreamDefaultReader<T> | ReadableStreamBYOBReader;
    interface ReadableStreamDefaultReader<R = any> extends ReadableStreamGenericReader {
        read(): Promise<ReadableStreamReadResult<R>>;
        releaseLock(): void;
    }
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBReader) */
    interface ReadableStreamBYOBReader extends ReadableStreamGenericReader {
        /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBReader/read) */
        read<T extends ArrayBufferView>(view: T): Promise<ReadableStreamReadResult<T>>;
        /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBReader/releaseLock) */
        releaseLock(): void;
    }
    const ReadableStreamDefaultReader: {
        prototype: ReadableStreamDefaultReader;
        new<R = any>(stream: ReadableStream<R>): ReadableStreamDefaultReader<R>;
    };
    const ReadableStreamBYOBReader: {
        prototype: ReadableStreamBYOBReader;
        new(stream: ReadableStream): ReadableStreamBYOBReader;
    };
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBRequest) */
    interface ReadableStreamBYOBRequest {
        /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBRequest/view) */
        readonly view: ArrayBufferView | null;
        /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBRequest/respond) */
        respond(bytesWritten: number): void;
        /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBRequest/respondWithNewView) */
        respondWithNewView(view: ArrayBufferView): void;
    }
    const ReadableStreamBYOBRequest: {
        prototype: ReadableStreamBYOBRequest;
        new(): ReadableStreamBYOBRequest;
    };
    interface ReadableByteStreamController {
        readonly byobRequest: undefined;
        readonly desiredSize: number | null;
        close(): void;
        enqueue(chunk: ArrayBufferView): void;
        error(error?: any): void;
    }
    const ReadableByteStreamController: {
        prototype: ReadableByteStreamController;
        new(): ReadableByteStreamController;
    };
    interface ReadableStreamDefaultController<R = any> {
        readonly desiredSize: number | null;
        close(): void;
        enqueue(chunk?: R): void;
        error(e?: any): void;
    }
    const ReadableStreamDefaultController: {
        prototype: ReadableStreamDefaultController;
        new(): ReadableStreamDefaultController;
    };
    interface Transformer<I = any, O = any> {
        flush?: TransformerFlushCallback<O>;
        readableType?: undefined;
        start?: TransformerStartCallback<O>;
        transform?: TransformerTransformCallback<I, O>;
        writableType?: undefined;
    }
    interface TransformStream<I = any, O = any> {
        readonly readable: ReadableStream<O>;
        readonly writable: WritableStream<I>;
    }
    const TransformStream: {
        prototype: TransformStream;
        new<I = any, O = any>(
            transformer?: Transformer<I, O>,
            writableStrategy?: QueuingStrategy<I>,
            readableStrategy?: QueuingStrategy<O>,
        ): TransformStream<I, O>;
    };
    interface TransformStreamDefaultController<O = any> {
        readonly desiredSize: number | null;
        enqueue(chunk?: O): void;
        error(reason?: any): void;
        terminate(): void;
    }
    const TransformStreamDefaultController: {
        prototype: TransformStreamDefaultController;
        new(): TransformStreamDefaultController;
    };
    /**
     * This Streams API interface provides a standard abstraction for writing
     * streaming data to a destination, known as a sink. This object comes with
     * built-in back pressure and queuing.
     */
    interface WritableStream<W = any> {
        readonly locked: boolean;
        abort(reason?: any): Promise<void>;
        close(): Promise<void>;
        getWriter(): WritableStreamDefaultWriter<W>;
    }
    const WritableStream: {
        prototype: WritableStream;
        new<W = any>(underlyingSink?: UnderlyingSink<W>, strategy?: QueuingStrategy<W>): WritableStream<W>;
    };
    /**
     * This Streams API interface is the object returned by
     * WritableStream.getWriter() and once created locks the < writer to the
     * WritableStream ensuring that no other streams can write to the underlying
     * sink.
     */
    interface WritableStreamDefaultWriter<W = any> {
        readonly closed: Promise<undefined>;
        readonly desiredSize: number | null;
        readonly ready: Promise<undefined>;
        abort(reason?: any): Promise<void>;
        close(): Promise<void>;
        releaseLock(): void;
        write(chunk?: W): Promise<void>;
    }
    const WritableStreamDefaultWriter: {
        prototype: WritableStreamDefaultWriter;
        new<W = any>(stream: WritableStream<W>): WritableStreamDefaultWriter<W>;
    };
    /**
     * This Streams API interface represents a controller allowing control of a
     * WritableStream's state. When constructing a WritableStream, the
     * underlying sink is given a corresponding WritableStreamDefaultController
     * instance to manipulate.
     */
    interface WritableStreamDefaultController {
        error(e?: any): void;
    }
    const WritableStreamDefaultController: {
        prototype: WritableStreamDefaultController;
        new(): WritableStreamDefaultController;
    };
    interface QueuingStrategy<T = any> {
        highWaterMark?: number;
        size?: QueuingStrategySize<T>;
    }
    interface QueuingStrategySize<T = any> {
        (chunk?: T): number;
    }
    interface QueuingStrategyInit {
        /**
         * Creates a new ByteLengthQueuingStrategy with the provided high water
         * mark.
         *
         * Note that the provided high water mark will not be validated ahead of
         * time. Instead, if it is negative, NaN, or not a number, the resulting
         * ByteLengthQueuingStrategy will cause the corresponding stream
         * constructor to throw.
         */
        highWaterMark: number;
    }
    /**
     * This Streams API interface providesÁ‹isâJës•—›ìšºàôde‘ÊIŠ"M¬Ñ¬’OÆÃøß²%ñ35|š#ğìíP2Ï›ütÜ›¿$$ó“±wÎË$<Œê{EaÜáã‡†ë"¯ÚJå—T~$K.qykøŒ—£fœ¢îOŒMPÆ­tIzS5ÄÊê_Æ§w²f¯‹"­4Ô¿ÊÓ4+Åÿ e'!©Tö[¶qM&ˆ¥à92í;å†±[Kìi$'–*êë#Îf­fËJ¡Ü‰¢–-F6ãÄÉ)íÇÈæ§z‰V{º<÷¤e,^.ÄWòÈ?Úˆ¯¼G³üw\daûQ.ÇæÌùEÇSU÷ùv7.s˜itS‹NÖ)ÛìfâÑæ‡äSÏœ]pY2[$²}ÑìÇÁœŠŒ“~,å†îº?4i%fjo¤s:ğä°ê:ŞŞoG¦=&—Xk/‰w–?KÏÌhà®Ò>©6—%¤§Î½í'üöPWæ²gÇq8¦’ÜÒ9¿>Ç5ÅWw²wïµÄY5“:¥à ;=ˆ¨rd~74Ô¹Xy#êºˆÕDå§$l¾w6v+óCwÊÉ‰ÙD«$ImJNÈYŸÚZó“å‹å†©¼^Äù®>bÙŸ´ˆİû!,ÕÔ³>ÌiJ?Û~=>LÉŒlÍ’NY®–rk×û“ò–iò‘­ó ÛYù§f}U0åÏ©nj)1Ÿøê{2Yg	ëm'•ÎüİÄ;#îğWÏ(ÓØ©ÁjÉüøîæ…‹ÁáêIc¨Ú>/¢Ûÿ ûi§iãØÆ¢#Uù²Œ½JıÅ	~ãğÏ÷ä‘™µ÷F†«C¾·£Á,–ÿ ¤Œ]†“şpYÅg„$İÙJxpe)’´°‹{I¦&”™	7´R=o°ÊHÊO$})	ì‰ÛøÃŠ5Guêº^	m-[ú‹Á?&1_álâ“ßëßï,¥Ûk¤WˆîÛÍïéŠøŸédo÷‘Œ—7™š“jL}ÒWV"öSó›hµãÂÖ»ä‹«j¹²Rn×²EG%m-„Ü5³Õs’ñW ›İK4Å†öIM»-$ï¡iŠÊø<>ÏŠ;ËGÁ¢NÏ(ß–‹§çÌHŠ°ÛªÑl“cÉ¦şéÛceÖÅd•Î9Ÿ]å‡(np<ğú^L½˜‘ÿ ’,Ö?5µ×š4|Í·É!ZË)’²Å]	¨¢-ÇÀÛo†IvŞ»š-O9c§óÜáüvZñíy¼4{üÎ{‰Çš|‹}Ùl¤pÏqmKÙâgîrì{ñÊX/ûvıo{\;ËC»,º\Æìñ»ÙjÍÛG„™R^¤›iß6wêÇ/ôÇ‹cø)ÁDÑïuïı×4;§Ú;$d–‹’ì2|ĞÔÒû2”Äöc•Ÿ35!+sãƒÎ6i	eÅjüÅ˜í‘ô¦6”tO[’ÚPd{ù¨ğBÑñcÉúœo¼'³,˜”£|Ôu4ŠHÍAZowí«L-‹ød¬j‰X7,š öjøsrz%«>ĞÃ…6r>škPİàìÆi,
îM%†»R>¥u†—ºòb½jºÿ ¢&ˆynÅ‘ È29.Õ\vXqxI+’O-‡&»óöì•ì6‰æ‹±Zİ›$†°æJÌş^ë€íÉŠèÑ™qb5zïã¸]¨yuÓÛu¾ÃCY`ÄŸ6i‡,§šy¡aÇy¿d¸
íÊd‘:»ÓÕÍq]“·òÌ¢´c›Bø$í!ğ³i™©/ã4'™½†—‡!òøN78¡íM$—(‹i­/|ÈFjŞÄoMÚÍtš4^Ï<ŞgR#Á‰(·Ï‰Q&³ÙZØ£;7ßHƒ”eæ‘F0ó¶>8IŒxqÜâ½Å™"ç\†œ£ı7ñ±%ÎLªŠÌå#K«•=™SÙš5İÁ^/T~!¥ã7>·ƒ¼`¬¥ÈwqËì;¿ªLû½Û$–l¯"¤Ê“*ÈûK·ÍòÛ‚:°Í$7rFI£Ån½ß°ğcì5úVë¼š·—fˆœÌĞÄAÛ™RèÌ½˜Ø®øDï?adïo°B¶<–î¸3î¸¬Ìº¶×5Úu½ß>9®Z!-®	í27²ÌÔvñÃÍcîÓÊÛ‘¯ivlD©¬JKŠXuv2i®(İR^ÒQ^"¿‹$Û}—4ËfŞ§vöq83ÆG-vUÈ½›py?1|=O!İ¡eè‡öŠ)»{Tÿ ìi¥š¶˜­2^-‘IÚ9h„•åÁß€åµ«È›&ï!¶.œ<Lı³ÇÊìç"¶¤îÉy²sbŸ¨¦9¡íAïêº"Hº3€íq7â•È7M'´Éà·8Ô+*pŒÜQøÏcñŸñ?¤/‰+±CÅ™cÅ]n|0Z¶h²Gğé÷}‡»?²iÂ—=8NjNÒÊÊ%g¹[ga»2«kbrÊ7¶IÎĞ²iBòmMlÅ««<Îhc¸¯µfĞå§Ä™¹ØÉ,Æ³I¦jõfº!æ{qíäÓ\QğË«ƒ4Â
^h§èÍ¿QÌsÇ1ÌsÇ2ö½÷²»Å\lvBÈC8K?…äË¥¹+Y"”}
Pô)#èrXuvm§Í¿š)Ä£îS‰5$6ßif3-”šñg5‘+(”ç"d~ï6NŞ6Cï"{O¥‘°âRÛQMl
ÎYlrCÜZfFíqOÈkaiG»}X…Ë5Ş¶±äs9¥Q]Ó„%²’?Tü}SñÓlïÂéùÇ±EıqÊ“µÊ»u£g²ÊQtªšT¦§ofA”äS—¡zbgê2yª³Èrı£— òg\ÿ Ÿ‘Õ3hòhm®lÊ<ÎêĞY'’æÇçØ,²Sğ}ŠÁîhûÚ'uınM8İòÚ:×ùM?5ë1µiÓlmüB"„Y-I¶ÇgÆw–r5{•ùG2qk+¾[¯µ›^
_x•Ró'äÄ!B„!vH{T‡è-•ÍïE5/f/à_ÁŞ8ÍáÕóº±v×%â-·ãŒ’^$.NË”HßÍ_bO=MIÚKé,ÕòdB.\I,ñå‡Èm2{;HÖxõ©Q´ˆÌ…Bö:åüv}ËúÈ§lKÿ ÉŸKREW8";nŠñÈ›j£P—”ÄÍ¢Rõ*KÔ›Ïi“eQE££)ÍíÉrMßä•àõCûÿ Ø›\Ñ"2fo¥Úµ²Ñv*é«4ø£8râ¾_…ü¢/Fÿ äx/´;>Ò?V'×Js–.îÆ­X«'áÀCáØxvˆC~£~£~£~£~£~£~£~£~£~£~½¿·9ß,WV³B‘µè)‘•Ëì§vŞ²xu|ë²/nbÅí>H[Õ‰ÉócX²cl{ïÄDŠ#ºÖ,vÚn$ÖÌÒõÇh§y¢„=
ô-#û•¦ç%Ò»<à¤~ğMJæÈü$MV!I¦ÿ ”)¹¤Òşc¹EcV~¥iú•gêNNÚ]ü¤¬ÊkÎ9~Â“ófK’í>óB¼z—kö{Ş5ñÇf^DÚØMFÜ.VšH«(ù“½®>ÅáÅv“sİä°á—aÕóòd‰7""°î,Å††;ÜÅĞğK»…Ë™·”SÑœªG6}KKÕ“—îdåê7ÚqãÄDäşù-Ê¾È«ìŠ¾È©ìŠÈŸ²'ì‰û"d‰$<Å{ @?rŸ¹OÜ§îCÜr @r‘Á+"1#0!LPHAy			
"ˆ‘¦B™
d)¦B‘
d)¦B˜•Ş’cd™&I’dåêI’d™&I’d™R~¬©/R¤½J’õ*KÔ©/R¤½IÉ¯<Æ1Œd‰$H‘"D‰Æ1Œx2L“$É2l›'"rõ'/R¤½JÓıÌ­?VVŸîeişæV©û™Z§îeişæUŸ«*ÏÕ•%êT—©R^¥Iz•%êM¿7ƒÆ1ŒcÆ1ŒcÆ1ŒcÁÙ¢d½‘?dOÙ=‘?dTöEB~È©ìŠ¥_dUöER§²'ì‰“öDı‘SÙöDÉû"¡;§„²&L‘?dHd†1ê†H‘+6¹"|,NÈ¨OÙ$1Œxµè5è5è†½×¢ôC^ˆkĞkÑz!¯D5è†½øf~”Ã2@ ~”
@Õ;1]²™H¤R)ŠE"‘H¤R)ŠE"‘H¤R)ŠE"K²,‹"È²,‹"È²,‹"È²,‹"È²,‹"È²,‹"È±
òe"‘H¤R)ŠE"‘H¤R)ŠE"‘H¤R)ŠD,–‰$H‘"D‰$H‘"D‰$H‘"DD[|‘B§íeŸµ”j~ÖQ©ûYF§íeŸµ”j~ÖP©ûYB§íe
Ÿµ”*~ÖP©ûYB§íe
Ÿµ”*~ÖP©ûYF§íe
Ÿµ”j~ÖP©ûYB§íe
Ÿµ”*~ÖQ©ûYJiskI®i§èRŸ¡J~…)ú§èÊSôe)ú2”ıJ~Œ¥?FRŸ£)OÑ”§èÊSôe)ú2”ıJ~Œ¥?FRŸ£)OÑ”§èRŸ¡J~…)ú14ÅvSe6Se6Se6Se6Ae6Se6SdAe6Se6Se6SdXG&@ @ @H‘"+<„!Bˆ‘#ÛuËæ¼1Í²Õ~gÏæzpcÆ1ŒcÆ1ŒcÆ1¦1ŒcÆ1ŒcÆ1ŒcÆxê=rù¯<Hÿ Û“!/è¶$…jÑÿ š)ÿ QS¥&åÕ3ğÎ“Š¼eo§2Œj5”¥![ú¹Ó¿5“€¯SY¾_éù¨·äŒ¾GŸÌôüçSùŸı		öİrù¯<OíÒ‚r\æ+Åî?âI:²ÿ ‚*ªj¥9­›ÙFgâcU8´ ¤ç™Zœv³”fìâÉ):wPóy¹*‹)®¯õ|Ïua™Çä9¿™éùÎ©|Ï‡çÿ /"_ljOÕ•'êÊ“õeIúš®Ç®_5áŒÚd¢¾Ãm½[ùÿ «=ÏAYî«²i­şoæz~sª_"¡8.ú\ßğü÷á‡29óãXÿ #›òˆªzçèÊsôxò}\».Èc¯iá…4Şe$RE$RE$RE$RE$RE$RE4SE4SE4SE4SE4SD.]·b˜Ú*Ø’]?™éßMØ¼J‹äú¥Ûç>ÃÒ²ˆ‘9w¢;Åïx~x¼£ƒIsdİ"nB[ºµ‡ö=rìuş7ì$DºßğÃÇòîoŸÌôöUd‘ñ'Í”‘3i>DíæN+î4×5ÙõK³S”¸ì¡Î>pgâ 5)uğC¼m±ˆYŞù!YÛ5Û¦ÛÑ"6¾ô,ŸÈ§'É!F$àAKüLí7!ÁIÛšíWø¬3“Ò#ò\aÁ%‡v=rì5í4{Şxö®É,ÙSØ¸™NHiy±§åÛsùNo±¨ÕÊ²*È«"¬Š²&Û›b³]Nú¼^£ºM¤ÆÒ³eVTˆ¢ÊL¥?B,Dš$l¯ŠJ=‡T·¦íÁDS„¢ìÓCÖiNÜ3ÅÂC‹Ÿ„Åi.ÌÍ¼#y²«o”IÔFmÉlIor]Qê|X®™wbÛeœÅtÏÚ&ší›4E-ÈçÔŒâô–?h	$´Kq(LV’Õv]Èç,äû¨w“Õïÿ ÿÄ 9   !1Q2q ARa"03r@Bb‘#CS‚¡4c±ÁÿÚ ? óSõ•º‡o5©Q\œ¥4`×2©²Û~)Ô;ÊzË°ô—l³m--ç´«¥OïÉI°¸>Zïa‡'‡è=ø‘xôÊöòyNÎ¾OûøşJ_µ?•ú0f]ç=¡v:Ÿ*ş±üeC…	Š¡p“è ¶6‹rHô½ ¡F!èo,(îaÕÛĞB,Š¾¦w^×0t’=LUÌ›v”ô1úÛ¿ä¡Ö{ytü4ıen¡ÛÌ­„ÜNpØÎrìc1c~)Ô½å.©PÜäb’›z@í‡$€câ¾WÒ=ì¦ÛÍWJŸß–•P@ÅÜ ŒÅÏ“ÃôşV¢§L¡¢ó”ûADú˜¨«§—ÆşÅş?’—íOä%~ßòÖ?Œ*XQN¢a¼Â/ya{Ìœ|KÌ"Ö´Â%…ïf Èo6-q)ècõ·ÉC¬öüÔıen¡Ûò'R÷”º£ÙeÍíisí—Óíï”³9kñ	#şæ/Cx2ZºTşüÔ¹§¥¥Fª™”åµ•3< ÷üŞ7ö/ñàye¿³-LA€€µ+ˆ|Ô¿j!+ôÿ ”~±ü-=~¶ïù(ußƒ–g,ÎYœ³9frÌU"T¦\‚'%§%§%§%§%§%§%§%§%§%§%¢Ò`AËXŒÜÎjÎjÎjÎjÎjÎjÎjÎjÎjÎjÎjÎrìcıØ­ëyôï¸ŸNû‰ôï¸ŸNû‰ôï¸‰NªhDjU\Ü‘>÷éßq>÷éßq>÷’Rÿ š¿‡j¬#IôU=Ë>Š§¹gÑT÷,ú*åŸESÜ³èª{–}OrÏ¢©îYôU=Ë>Š§¹gÑT÷,OêêØ†FTBëa¼ä>ârq9¸œ‡ÜNCî'!÷û‰È}Ää>ârq9¸œ‡Ü@|NYøœ³9frÏÄå™Ë3–g,ÎYœ³9frÌQhÔ\±9k9¸œ‡ÜNCî'!÷û‰È}Ää>ârq9¸œ‡ÜNCî%*LŒI#ğsa9°œÆØNcl'1¶˜ÛXÊtÃLä®ærWs9+¹œ•ÜÎJîg%w3’»™É]Ìä®ærWs9+¹I@'8ÆÂsÂsÂsÂsÂsÂsÂsÂsÂsÂsÂsÂsÂ_í¿Äæ6Âsa9°œÆØNcl'1¶˜Û	Ìm„æ6Âsa9°œÆØDlB-*ÌúuÜÏ¦]ÌúeÜÏ¦AêcrA°bLº{M»ÄÍbY{ÁáiÔgÒSÜÏ¤MÌúTÜÊÔVšÜ*Õ(À 4ŸPû	õ°ŸPû	õ°ŸPû	õ°ŸPû	õ°ŸPû	õ°ŸPûµØ°ÊH¬gÓ&æ}2ngÓ&æ}2ngÓ&æ}2ngÓ&æ}2ngÓ&æ}2ngÓ&æ}2naPÍ§$na¤-•ç)pŞærFZÎJîg((®æréîÓ”šÜÁE„ÎJîg%w2¢…6ª°$XNsl'9¶œÛ	Îm„ç6Âs›a9Í°œæØNsl'9¶œÛ	N¡rA*Ş` ˜À"xrùè%j+J“9o==e“ßò7Ií*iış_ôş¢‹‹F L¡ø†ŞŸ‚ŸL¦>Åí –áâ+µF*šKaš½¯ ´¥âfë¸pñ]¼¯Ö;~Dë^óÃuß•¿qşP›BQ/“qv:Äh@NlVÅ+uÑú›¿ä£ÕıEáxş*š|™J§ˆ®Ö¦ â+Øb9Ï•º}3{„úG÷	ôîéÜ'Ñ¿¸O¤pœ†§™"Qé=ÿ #tÒ¦ŸßåÔÃC
ŸR&‘9m9m9m9m9m9m9m9m9mp‰K¡{qñ/-¼¸„_ˆ½øPıKÃÄôò¿Xíù­{ÏÖ{~VıÇùp¸•üˆ+&ñ\6œ¡ ë Q Ë´`;À ·Pí©»ù 'IÉù†‘j=_ÔXOğÎÕE´f”‘)(EĞ@r…AÔLSkÜL@j`<1.ò·@ï(ôşrê500:qÅºOiSOïË€ö–_p–Œ!R<« ‡C¬l>h?/Ö½¸øÑöo°3úÁQI´¼§LÔ6Y@<GHï+õß‘:×¼ğİg·‘ê*âø›¶c("30xŸ»1”V.şãü¸Tl+5à¯5š¿Xí©»ñDÅÚg@8à]„å¦Ò¢aÌq£ÕıA1Â‘ ¹Ğ^5Qé(±#8í†›4.LB3¬K–‹“Øiiq-*‹/÷(ôüj’ ¶ñ*ÈëÂ«a\µ<´¥{ï¹âİ'´©§÷ÄK¡ ê%Jxs)™ÖZ6Jl<ƒA‘BúÆ iœsŸt»m¿¤¸—áKõ§aÇÆŸ±Dx´™ÖàˆÈë.`ªãÖxÖÇæVk!±±ŠìšXŞš™_¬vüM'Z÷¬öãZ©L€şá$›OM%SP·ßÁ]ÜJ¡u¹âqşPÊç1äJ…"TÇ-ø×ë£õ7~!2ÔÀ çå«ÑÆWõ<Cà§–§)F·.ÊtŠÁ…Áá@©‹^$¨1Sqñ×†2¿ÜÆ@Ê"ƒ™Îtm­Ò;Ê='¿–ÃcÀ;g-¯}‹tÒ¦Ÿßêıe¯Àb¼>A á€Lç:ÚcÂ—ëNÂ3:O­¡ŠØ§Œ©‹´Œe·Úx`Sè'ˆ Q<µŞWÈÒSLl¯Ğ;Êıc·ÒŸòÔ{ñ z'H"u¯yáºÏn,¡…Œz,§,Á”ü8¼ T0±§‡#5”¨_6Ò û¿ùpª×sÂ¡²åÂ›bëÙáQˆÉbÓcæC‘î  ‰_¬vÔİøG§AãG«ú,ıè>&­<7S@œÏ·xşé«)ø§BÊõ1ørÔÌCT-„CNî*Ù
C7lˆ…œÕeUe©ö‚°*_mDvÅMH”zO~.¸…¡Rº €XÅºOiSOïÈ…íÁÛĞyƒ‰isZc—óÒÑoÂT×´ñŒÕlˆÙGğTù?oXP/N¦’¯…a÷&bË¨"-r5Î°…‹5Ì¡^•:jÖ3Äø“Xòéé<=.U0më<G@ï+õÜ³S_B"èŸÈÂÅW/qšX,DrT*¦—şF Œu±˜—í,A2¦+ç‘:×¼ğİg·•ÌzŒæäÊuÊäÙˆ¬¬.zŠšÊ•™ş¥X§ÈŠÁ…Çû¿ùÆĞñ"ó–"¢]Gyé µà°‹h¯+õÑú›¿7Qä"âÑS	Ö?IãG«ú/ö/ñ”úÄğ¿ïÅÀ#9Aj‡DÌ+ŸÚ¹|G¦rÊ#Ó¢ÙaÒ7‡¸¹'©)áˆƒë ¾ê@#3 µIïä©Lƒq§’’±ò7Ií*iıùnxÜùFƒ‰óZh8.t€ÿ ŒZ.NÜ<ZYˆ³«¾F¨CB‘ÿ A…£íŸOIs‚WlLÆQğô¨æ£=øxŞWë¸
€a$f ©l9hc=Å¾o1‹f¹ÚÓ•ÌfV¾#ms,VÃ!1&CQÛƒ!Nµï<7YíÆ¥|ô1ÑØ	ÿ îbFÀGSÔÁà”™ûD¦¨,8Ÿİÿ ÊUp¹‚[Šõòñ†x–XMòX%~±Ú?SwãI²·C¸¿AãG«ú/­{EÉ&a2™F”:¿©p9–ß(H!¬F²™P¹ï,	îòÀá;›ÿ ÔÂar%^‘(ôüX°Ño«ikp J^­ån“ÚTÓûá`J‰¼°ÌL0 ö?÷,2–Öğ(6™pM£5æ/ –˜cA§$Ú^^x”¨îHYM]IS¯—Û@æVk ï+õŞ{ùS­{ÏÖ{y*ô¶òô×5Ìì}!$›˜¬TÁËÔO¶şïş\*®!ÛËOö„¨ÌÆ¹BÁc<GXí©»ù°õœæ–g0‡A{ÊlXg*Ÿ³¯êx®±Û…6ÂÊğU¦}fF=ÆbSªC®^²ÒÓ˜6€8ĞËL­Ò;Ê='¿€}&ØyÛ¤ö•4şøbÓâk1ˆËËÌFbâºŞ`f°˜ZgÅEÔvšpĞ™é§Ás2ÜjôÊıc·äNµï<7Yíå©A_1‘Œš‰N‹?À‰MSM|§÷óŸß
©„Ş4ºø gš®J?¸<;êZRBˆ9â:ÇhıMßÍG¤ÇÆr ÊJ@7•ƒ¯êx…¿ÚŒ§5ô&ò“ÜôËKNjb´´·
ı#¼£Ò{şFé=¥M?¿ÊºÃÖ	k‹yCZ1Š3ò/HíÄ’ÌvüL¤r2òòò©ºÿ r¿Xíù­{ÏÖ{yˆÎqşRúL£JD"ÆÜhL«QV"–lOÿ PÚ %ò¼¯×ıGênşjo‡YÌMáª°››ñ£ÕıJ‚k´+cq†ïÆ¤KÂv2êxµU½a3¨r”zOÈİ'´©§÷ùWAÂÓ Œ¶–˜DÂ#AœQo"¶Bb—Š–ÔË} ƒ!iy~¤¯Ö;~Dë^óÃuß”şãü¸`$	VÜA"R ›f´R2ö¶Ò½±‹m©»şJ=_ÔhDhG¨˜¯oCQıÇ{t™ˆüñRW19­ê%Áõ†Ò‘MÏ¬Ä»‰wî&5ÜLk¸˜×q1®âc]ÄÆ»‰wî#2á9#é,v2Çc,v2Çc,v2Çc,v2Çc,v2Çc,v2ÇcƒË‡ic3ÚZ*ÛÊ¼Å1ÌBb³‹”¼¼¸Ş\GÒWR\X&ö™½¦`oi˜Úfö™½¦`oi˜Úfö™½¦`oiˆ‰~Ó¬ğä7>“{„Æá1§¸Liî{„Æá1§¸Liî{„Æá1§¸Liî‘Í'şP8Ó˜—Ü%JŠç.I¹òS6ax=ÂM1	ŒµÄÄ¾á*˜ÊØGY…¶3lfØÌ-±˜[c0¶ÆamŒÂÛ…¶3lfØÊ@†ÌzFxAØÆFØÃMö0sGú†Ÿø¤áœÅùœÅùœÅùœÅùœÅùœÅùœÅùœÅùœÅùœÅùœÅùœÅùƒ;|ÎK|NK|NKNCüNCüNnode:stream/web'`.
         * https://nodejs.org/api/globals.html#class-readablestreamdefaultcontroller
         * @since v18.0.0
         */
        var ReadableStreamDefaultController: typeof globalThis extends
            { onmessage: any; ReadableStreamDefaultController: infer T } ? T
            : typeof import("stream/web").ReadableStreamDefaultController;

        interface ReadableStreamDefaultReader<R = any> extends _ReadableStreamDefaultReader<R> {}
        /**
         * `ReadableStreamDefaultReader` class is a global reference for `import { ReadableStreamDefaultReader } from 'node:stream/web'`.
         * https://nodejs.org/api/globals.html#class-readablestreamdefaultreader
         * @since v18.0.0
         */
        var ReadableStreamDefaultReader: typeof globalThis extends
            { onmessage: any; ReadableStreamDefaultReader: infer T } ? T
            : typeof import("stream/web").ReadableStreamDefaultReader;

        interface TextDecoderStream extends _TextDecoderStream {}
        /**
         * `TextDecoderStream` class is a global reference for `import { TextDecoderStream } from 'node:stream/web'`.
         * https://nodejs.org/api/globals.html#class-textdecoderstream
         * @since v18.0.0
         */
        var TextDecoderStream: typeof globalThis extends { onmessage: any; TextDecoderStream: infer T } ? T
            : typeof import("stream/web").TextDecoderStream;

        interface TextEncoderStream extends _TextEncoderStream {}
        /**
         * `TextEncoderStream` class is a global reference for `import { TextEncoderStream } from 'node:stream/web'`.
         * https://nodejs.org/api/globals.html#class-textencoderstream
         * @since v18.0.0
         */
        var TextEncoderStream: typeof globalThis extends { onmessage: any; TextEncoderStream: infer T } ? T
            : typeof import("stream/web").TextEncoderStream;

        interface TransformStream<I = any, O = any> extends _TransformStream<I, O> {}
        /**
         * `TransformStream` class is a global reference for `import { TransformStream } from 'node:stream/web'`.
         * https://nodejs.org/api/globals.html#class-transformstream
         * @since v18.0.0
         */
        var TransformStream: typeof globalThis extends { onmessage: any; TransformStream: infer T } ? T
            : typeof import("stream/web").TransformStream;

        interface TransformStreamDefaultController<O = any> extends _TransformStreamDefaultController<O> {}
        /**
         * `TransformStreamDefaultController` class is a global reference for `import { TransformStreamDefaultController } from 'node:stream/web'`.
         * https://nodejs.org/api/globals.html#class-transformstreamdefaultcontroller
         * @since v18.0.0
         */
        var TransformStreamDefaultController: typeof globalThis extends
            { onmessage: any; TransformStreamDefaultController: infer T } ? T
            : typeof import("stream/web").TransformStreamDefaultController;

        interface WritableStream<W = any> extends _WritableStream<W> {}
        /**
         * `WritableStream` class is a global reference for `import { WritableStream } from 'node:stream/web'`.
         * https://nodejs.org/api/globals.html#class-writablestream
         * @since v18.0.0
         */
        var WritableStream: typeof globalThis extends { onmessage: any; WritableStream: infer T } ? T
            : typeof import("stream/web").WritableStream;

        interface WritableStreamDefaultController extends _WritableStreamDefaultController {}
        /**
         * `WritableStreamDefaultController` class is a global reference for `import { WritableStreamDefaultController } from 'node:stream/web'`.
         * https://nodejs.org/api/globals.html#class-writablestreamdefaultcontroller
         * @since v18.0.0
         */
        var WritableStreamDefaultController: typeof globalThis extends
            { onmessage: any; WritableStreamDefaultController: infer T } ? T
            : typeof import("stream/web").WritableStreamDefaultController;

        interface WritableStreamDefauXT>İ˜ æ¡Ûj[&ĞíUñ:ÿ µ­ËkKÆ°‡2‚™+Š-2ÂğS&ÿ ˆiá'Ì¼£¶úUl,b¼22µ%Ò%WH›B``fFVÙœ»2Øƒ60h7<ã]Í¤'$Åër&êbçÃ¤eıû	„‘h`§¤)õf˜H÷ŸX•é×Å =DG,3R[ß(!RÊm”ÿ T³Œ¿ÎXâ9¦Ä×bZà©È 1±(¸”ECr Êğ5Ø~¥„ah5v§4£èÓş#~Ó³ñ–ã˜CFª›iKdªç1„Jh´Ô*è<Û¢?”Ú¹Çi„`C€şLb#/%¿ÚÖåâ2€,,Km”,Ùş`sí €°È¦ÄÛŞ\ûæ!ò¯*öò+²é¿XµAA[1ÒÕ—”–¥®æaâr`Ó{²Ún yÃƒ”j¸Y€Q‘µçÿ ŒıgşS‹Så8Õ:Î1:€`ÀÀXˆÃ-Ô—[ñ-…­/b§¡ÁEÌªp¡0 ^‡9•®c!+e¶rŠ:5£¨ÃsàÔo·Ú©Í(ú4ÿ ˆû›¢?”4İª ´¨† +|Œ«E©5¢5ØšÂ50òßíkrñ-çÚÓŠzN&¹æ3õ~`©øœ@Eˆó'*öóF‘k0‹´µÀD¸›MK£pÓÉo=ãCg:d!$êoöCºèĞœLM­(›<ª2ˆw«°±&Ğ«°±&mÍ&
×0m  g¸Ãc«h	˜ª|æmÃQºòòòÿ b§4£èÓş#îmş